// Generated by Haxe 3.4.0 (git build development @ 75c0f05)
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_VorbisDecodeState
#include <stb/format/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_VorbisTools
#include <stb/format/vorbis/VorbisTools.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Codebook
#include <stb/format/vorbis/data/Codebook.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderError
#include <stb/format/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderErrorType
#include <stb/format/vorbis/data/ReaderErrorType.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_34_new,"stb.format.vorbis.data.Codebook","new",0xf64bc71b,"stb.format.vorbis.data.Codebook.new","stb/format/vorbis/data/Codebook.hx",34,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_189_addEntry,"stb.format.vorbis.data.Codebook","addEntry",0x840c61f6,"stb.format.vorbis.data.Codebook.addEntry","stb/format/vorbis/data/Codebook.hx",189,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_200_includeInSort,"stb.format.vorbis.data.Codebook","includeInSort",0x453654a6,"stb.format.vorbis.data.Codebook.includeInSort","stb/format/vorbis/data/Codebook.hx",200,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_214_computeCodewords,"stb.format.vorbis.data.Codebook","computeCodewords",0xe6a71d0a,"stb.format.vorbis.data.Codebook.computeCodewords","stb/format/vorbis/data/Codebook.hx",214,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_284_computeSortedHuffman,"stb.format.vorbis.data.Codebook","computeSortedHuffman",0x4a7ac65e,"stb.format.vorbis.data.Codebook.computeSortedHuffman","stb/format/vorbis/data/Codebook.hx",284,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_341_computeAcceleratedHuffman,"stb.format.vorbis.data.Codebook","computeAcceleratedHuffman",0x9fa36558,"stb.format.vorbis.data.Codebook.computeAcceleratedHuffman","stb/format/vorbis/data/Codebook.hx",341,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_367_codebookDecode,"stb.format.vorbis.data.Codebook","codebookDecode",0xd2a202c9,"stb.format.vorbis.data.Codebook.codebookDecode","stb/format/vorbis/data/Codebook.hx",367,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_415_codebookDecodeStep,"stb.format.vorbis.data.Codebook","codebookDecodeStep",0x8b8aaeb5,"stb.format.vorbis.data.Codebook.codebookDecodeStep","stb/format/vorbis/data/Codebook.hx",415,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_459_decodeStart,"stb.format.vorbis.data.Codebook","decodeStart",0xa25aaa0f,"stb.format.vorbis.data.Codebook.decodeStart","stb/format/vorbis/data/Codebook.hx",459,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_483_decodeDeinterleaveRepeat,"stb.format.vorbis.data.Codebook","decodeDeinterleaveRepeat",0x09829dca,"stb.format.vorbis.data.Codebook.decodeDeinterleaveRepeat","stb/format/vorbis/data/Codebook.hx",483,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_574_residueDecode,"stb.format.vorbis.data.Codebook","residueDecode",0xdcc82254,"stb.format.vorbis.data.Codebook.residueDecode","stb/format/vorbis/data/Codebook.hx",574,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_37_read,"stb.format.vorbis.data.Codebook","read",0x8ea7383b,"stb.format.vorbis.data.Codebook.read","stb/format/vorbis/data/Codebook.hx",37,0x8b5de635)
static const int _hx_array_data_19459da9_62[] = {
	(int)0,(int)1,(int)2,(int)2,(int)3,(int)3,(int)3,(int)3,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,
};
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_15_boot,"stb.format.vorbis.data.Codebook","boot",0x841b7117,"stb.format.vorbis.data.Codebook.boot","stb/format/vorbis/data/Codebook.hx",15,0x8b5de635)
HX_DEFINE_STACK_FRAME(_hx_pos_8f92f7adc9e5843d_480_boot,"stb.format.vorbis.data.Codebook","boot",0x841b7117,"stb.format.vorbis.data.Codebook.boot","stb/format/vorbis/data/Codebook.hx",480,0x8b5de635)
namespace stb{
namespace format{
namespace vorbis{
namespace data{

void Codebook_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_34_new)
            	HX_STACK_THIS(this)
            	}

Dynamic Codebook_obj::__CreateEmpty() { return new Codebook_obj; }

void *Codebook_obj::_hx_vtable = 0;

Dynamic Codebook_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Codebook_obj > _hx_result = new Codebook_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Codebook_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2a4d6403;
}

void Codebook_obj::addEntry(int huffCode,int symbol,int count,int len,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_189_addEntry)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(huffCode,"huffCode")
            	HX_STACK_ARG(symbol,"symbol")
            	HX_STACK_ARG(count,"count")
            	HX_STACK_ARG(len,"len")
            	HX_STACK_ARG(values,"values")
HXLINE( 189)		if (!(this->sparse)) {
HXLINE( 190)			this->codewords->__unsafe_set(symbol,huffCode);
            		}
            		else {
HXLINE( 192)			this->codewords->__unsafe_set(count,huffCode);
HXLINE( 193)			this->codewordLengths->__unsafe_set(count,len);
HXLINE( 194)			values->__unsafe_set(count,symbol);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,addEntry,(void))

bool Codebook_obj::includeInSort(int len){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_200_includeInSort)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(len,"len")
HXLINE( 200)		if (this->sparse) {
HXLINE( 200)			return true;
            		}
            		else {
HXLINE( 203)			if ((len == (int)255)) {
HXLINE( 200)				return false;
            			}
            			else {
HXLINE( 205)				if ((len > (int)10)) {
HXLINE( 200)					return true;
            				}
            				else {
HXLINE( 200)					return false;
            				}
            			}
            		}
HXDLIN( 200)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,includeInSort,return )

bool Codebook_obj::computeCodewords(::Array< int > len,int n,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_214_computeCodewords)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(len,"len")
            	HX_STACK_ARG(n,"n")
            	HX_STACK_ARG(values,"values")
HXLINE( 215)		HX_VARI( ::Array< int >,available) = ::Array_obj< int >::__new((int)32);
HXLINE( 216)		{
HXLINE( 216)			HX_VARI( int,_g) = (int)0;
HXDLIN( 216)			while((_g < (int)32)){
HXLINE( 216)				_g = (_g + (int)1);
HXDLIN( 216)				available->__unsafe_set((_g - (int)1),(int)0);
            			}
            		}
HXLINE( 219)		HX_VARI( int,k) = (int)0;
HXLINE( 220)		while((k < n)){
HXLINE( 221)			if ((( (int)(_hx_array_unsafe_get(len,k)) ) < (int)255)) {
HXLINE( 222)				goto _hx_goto_4;
            			}
HXLINE( 224)			k = (k + (int)1);
            		}
            		_hx_goto_4:;
HXLINE( 227)		if ((k == n)) {
HXLINE( 229)			return true;
            		}
HXLINE( 232)		HX_VARI( int,m) = (int)0;
HXLINE( 235)		{
HXLINE( 235)			m = (int)1;
HXDLIN( 235)			int len1 = ( (int)(_hx_array_unsafe_get(len,k)) );
HXDLIN( 235)			if (!(this->sparse)) {
HXLINE( 235)				this->codewords->__unsafe_set(k,(int)0);
            			}
            			else {
HXLINE( 235)				this->codewords->__unsafe_set((int)0,(int)0);
HXDLIN( 235)				this->codewordLengths->__unsafe_set((int)0,len1);
HXDLIN( 235)				values->__unsafe_set((int)0,k);
            			}
            		}
HXLINE( 238)		HX_VARI( int,i) = (int)0;
HXLINE( 240)		while(true){
HXLINE( 240)			i = (i + (int)1);
HXDLIN( 240)			if (!((i <= ( (int)(_hx_array_unsafe_get(len,k)) )))) {
HXLINE( 240)				goto _hx_goto_5;
            			}
HXLINE( 241)			available->__unsafe_set(i,((int)(int)1 << (int)((int)32 - i)));
            		}
            		_hx_goto_5:;
HXLINE( 248)		i = k;
HXLINE( 249)		while(true){
HXLINE( 249)			i = (i + (int)1);
HXDLIN( 249)			if (!((i < n))) {
HXLINE( 249)				goto _hx_goto_6;
            			}
HXLINE( 250)			HX_VARI( int,z) = ( (int)(_hx_array_unsafe_get(len,i)) );
HXLINE( 251)			if ((z == (int)255)) {
HXLINE( 251)				continue;
            			}
HXLINE( 259)			while(true){
HXLINE( 259)				bool _hx_tmp;
HXDLIN( 259)				if ((z > (int)0)) {
HXLINE( 259)					_hx_tmp = (( (int)(_hx_array_unsafe_get(available,z)) ) == (int)0);
            				}
            				else {
HXLINE( 259)					_hx_tmp = false;
            				}
HXDLIN( 259)				if (!(_hx_tmp)) {
HXLINE( 259)					goto _hx_goto_7;
            				}
HXDLIN( 259)				z = (z - (int)1);
            			}
            			_hx_goto_7:;
HXLINE( 260)			if ((z == (int)0)) {
HXLINE( 261)				return false;
            			}
HXLINE( 264)			HX_VARI( int,res) = ( (int)(_hx_array_unsafe_get(available,z)) );
HXLINE( 265)			available->__unsafe_set(z,(int)0);
HXLINE( 266)			{
HXLINE( 266)				HX_VARI_NAME( int,n1,"n") = res;
HXDLIN( 266)				n1 = ((int)hx::UShr(((int)res & (int)(int)-1431655766),(int)1) | (int)((int)((int)res & (int)(int)1431655765) << (int)(int)1));
HXDLIN( 266)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-858993460),(int)2) | (int)((int)((int)n1 & (int)(int)858993459) << (int)(int)2));
HXDLIN( 266)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-252645136),(int)4) | (int)((int)((int)n1 & (int)(int)252645135) << (int)(int)4));
HXDLIN( 266)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-16711936),(int)8) | (int)((int)((int)n1 & (int)(int)16711935) << (int)(int)8));
HXDLIN( 266)				HX_VARI( int,huffCode) = ((int)hx::UShr(n1,(int)16) | (int)((int)n1 << (int)(int)16));
HXDLIN( 266)				m = (m + (int)1);
HXDLIN( 266)				HX_VARI( int,count) = (m - (int)1);
HXDLIN( 266)				int len2 = ( (int)(_hx_array_unsafe_get(len,i)) );
HXDLIN( 266)				if (!(this->sparse)) {
HXLINE( 266)					this->codewords->__unsafe_set(i,huffCode);
            				}
            				else {
HXLINE( 266)					this->codewords->__unsafe_set(count,huffCode);
HXDLIN( 266)					this->codewordLengths->__unsafe_set(count,len2);
HXDLIN( 266)					values->__unsafe_set(count,i);
            				}
            			}
HXLINE( 269)			if ((z != ( (int)(_hx_array_unsafe_get(len,i)) ))) {
HXLINE( 270)				HX_VARI( int,y) = ( (int)(_hx_array_unsafe_get(len,i)) );
HXLINE( 271)				while((y > z)){
HXLINE( 272)					_hx_array_unsafe_get(available,y);
HXLINE( 273)					available->__unsafe_set(y,(res + ((int)(int)1 << (int)((int)32 - y))));
HXLINE( 274)					y = (y - (int)1);
            				}
            			}
            		}
            		_hx_goto_6:;
HXLINE( 279)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Codebook_obj,computeCodewords,return )

void Codebook_obj::computeSortedHuffman(::Array< int > lengths,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_284_computeSortedHuffman)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(lengths,"lengths")
            	HX_STACK_ARG(values,"values")
HXLINE( 289)		if (!(this->sparse)) {
HXLINE( 290)			HX_VARI( int,k) = (int)0;
HXLINE( 291)			{
HXLINE( 291)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 291)				HX_VARI( int,_g) = this->entries;
HXDLIN( 291)				while((_g1 < _g)){
HXLINE( 291)					_g1 = (_g1 + (int)1);
HXDLIN( 291)					HX_VARI( int,i) = (_g1 - (int)1);
HXLINE( 292)					HX_VARI( int,len) = ( (int)(_hx_array_unsafe_get(lengths,i)) );
HXDLIN( 292)					bool _hx_tmp;
HXDLIN( 292)					if (this->sparse) {
HXLINE( 292)						_hx_tmp = true;
            					}
            					else {
HXLINE( 292)						if ((len == (int)255)) {
HXLINE( 292)							_hx_tmp = false;
            						}
            						else {
HXLINE( 292)							if ((len > (int)10)) {
HXLINE( 292)								_hx_tmp = true;
            							}
            							else {
HXLINE( 292)								_hx_tmp = false;
            							}
            						}
            					}
HXDLIN( 292)					if (_hx_tmp) {
HXLINE( 293)						::Array< int > _hx_tmp1 = this->sortedCodewords;
HXDLIN( 293)						k = (k + (int)1);
HXDLIN( 293)						HX_VARI( int,n) = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
HXDLIN( 293)						n = ((int)hx::UShr(((int)n & (int)(int)-1431655766),(int)1) | (int)((int)((int)n & (int)(int)1431655765) << (int)(int)1));
HXDLIN( 293)						n = ((int)hx::UShr(((int)n & (int)(int)-858993460),(int)2) | (int)((int)((int)n & (int)(int)858993459) << (int)(int)2));
HXDLIN( 293)						n = ((int)hx::UShr(((int)n & (int)(int)-252645136),(int)4) | (int)((int)((int)n & (int)(int)252645135) << (int)(int)4));
HXDLIN( 293)						n = ((int)hx::UShr(((int)n & (int)(int)-16711936),(int)8) | (int)((int)((int)n & (int)(int)16711935) << (int)(int)8));
HXDLIN( 293)						_hx_tmp1[(k - (int)1)] = ((int)hx::UShr(n,(int)16) | (int)((int)n << (int)(int)16));
            					}
            				}
            			}
            		}
            		else {
HXLINE( 298)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 298)			HX_VARI_NAME( int,_g2,"_g") = this->sortedEntries;
HXDLIN( 298)			while((_g11 < _g2)){
HXLINE( 298)				_g11 = (_g11 + (int)1);
HXDLIN( 298)				HX_VARI_NAME( int,i1,"i") = (_g11 - (int)1);
HXLINE( 299)				::Array< int > _hx_tmp2 = this->sortedCodewords;
HXDLIN( 299)				HX_VARI_NAME( int,n1,"n") = ( (int)(_hx_array_unsafe_get(this->codewords,i1)) );
HXDLIN( 299)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-1431655766),(int)1) | (int)((int)((int)n1 & (int)(int)1431655765) << (int)(int)1));
HXDLIN( 299)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-858993460),(int)2) | (int)((int)((int)n1 & (int)(int)858993459) << (int)(int)2));
HXDLIN( 299)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-252645136),(int)4) | (int)((int)((int)n1 & (int)(int)252645135) << (int)(int)4));
HXDLIN( 299)				n1 = ((int)hx::UShr(((int)n1 & (int)(int)-16711936),(int)8) | (int)((int)((int)n1 & (int)(int)16711935) << (int)(int)8));
HXDLIN( 299)				_hx_tmp2[i1] = ((int)hx::UShr(n1,(int)16) | (int)((int)n1 << (int)(int)16));
            			}
            		}
HXLINE( 303)		this->sortedCodewords[this->sortedEntries] = (int)-1;
HXLINE( 304)		this->sortedCodewords->sort(::stb::format::vorbis::VorbisTools_obj::uintAsc_dyn());
HXLINE( 306)		HX_VAR_NAME( int,len1,"len");
HXDLIN( 306)		if (this->sparse) {
HXLINE( 306)			len1 = this->sortedEntries;
            		}
            		else {
HXLINE( 306)			len1 = this->entries;
            		}
HXLINE( 312)		{
HXLINE( 312)			HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN( 312)			HX_VARI_NAME( int,_g3,"_g") = len1;
HXDLIN( 312)			while((_g12 < _g3)){
HXLINE( 312)				_g12 = (_g12 + (int)1);
HXDLIN( 312)				HX_VARI_NAME( int,i2,"i") = (_g12 - (int)1);
HXLINE( 313)				HX_VAR( int,huffLen);
HXDLIN( 313)				if (this->sparse) {
HXLINE( 313)					huffLen = ( (int)(_hx_array_unsafe_get(lengths,( (int)(_hx_array_unsafe_get(values,i2)) ))) );
            				}
            				else {
HXLINE( 313)					huffLen = ( (int)(_hx_array_unsafe_get(lengths,i2)) );
            				}
HXLINE( 314)				bool _hx_tmp3;
HXDLIN( 314)				if (this->sparse) {
HXLINE( 314)					_hx_tmp3 = true;
            				}
            				else {
HXLINE( 314)					if ((huffLen == (int)255)) {
HXLINE( 314)						_hx_tmp3 = false;
            					}
            					else {
HXLINE( 314)						if ((huffLen > (int)10)) {
HXLINE( 314)							_hx_tmp3 = true;
            						}
            						else {
HXLINE( 314)							_hx_tmp3 = false;
            						}
            					}
            				}
HXDLIN( 314)				if (_hx_tmp3) {
HXLINE( 315)					HX_VARI_NAME( int,n2,"n") = ( (int)(_hx_array_unsafe_get(this->codewords,i2)) );
HXDLIN( 315)					n2 = ((int)hx::UShr(((int)n2 & (int)(int)-1431655766),(int)1) | (int)((int)((int)n2 & (int)(int)1431655765) << (int)(int)1));
HXDLIN( 315)					n2 = ((int)hx::UShr(((int)n2 & (int)(int)-858993460),(int)2) | (int)((int)((int)n2 & (int)(int)858993459) << (int)(int)2));
HXDLIN( 315)					n2 = ((int)hx::UShr(((int)n2 & (int)(int)-252645136),(int)4) | (int)((int)((int)n2 & (int)(int)252645135) << (int)(int)4));
HXDLIN( 315)					n2 = ((int)hx::UShr(((int)n2 & (int)(int)-16711936),(int)8) | (int)((int)((int)n2 & (int)(int)16711935) << (int)(int)8));
HXDLIN( 315)					HX_VARI( int,code) = ((int)hx::UShr(n2,(int)16) | (int)((int)n2 << (int)(int)16));
HXLINE( 316)					HX_VARI( int,x) = (int)0;
HXLINE( 317)					HX_VARI_NAME( int,n3,"n") = this->sortedEntries;
HXLINE( 318)					while((n3 > (int)1)){
HXLINE( 320)						HX_VARI( int,m) = (x + ((int)n3 >> (int)(int)1));
HXLINE( 321)						HX_VARI( int,a) = this->sortedCodewords->__get(m);
HXDLIN( 321)						HX_VARI( bool,aNeg) = (code < (int)0);
HXDLIN( 321)						bool _hx_tmp4;
HXDLIN( 321)						if ((aNeg != (a < (int)0))) {
HXLINE( 321)							_hx_tmp4 = aNeg;
            						}
            						else {
HXLINE( 321)							_hx_tmp4 = (code >= a);
            						}
HXDLIN( 321)						if (_hx_tmp4) {
HXLINE( 322)							x = m;
HXLINE( 323)							n3 = (n3 - ((int)n3 >> (int)(int)1));
            						}
            						else {
HXLINE( 325)							n3 = ((int)n3 >> (int)(int)1);
            						}
            					}
HXLINE( 330)					if (this->sparse) {
HXLINE( 331)						{
HXLINE( 331)							::Array< int > this1 = this->sortedValues;
HXDLIN( 331)							int val = ( (int)(_hx_array_unsafe_get(values,i2)) );
HXDLIN( 331)							this1->__unsafe_set(x,val);
            						}
HXLINE( 332)						this->codewordLengths->__unsafe_set(x,huffLen);
            					}
            					else {
HXLINE( 334)						this->sortedValues->__unsafe_set(x,i2);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Codebook_obj,computeSortedHuffman,(void))

void Codebook_obj::computeAcceleratedHuffman(){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_341_computeAcceleratedHuffman)
            	HX_STACK_THIS(this)
HXLINE( 342)		this->fastHuffman = ::Array_obj< int >::__new((int)1024);
HXLINE( 343)		this->fastHuffman->__unsafe_set((int)0,(int)-1);
HXLINE( 344)		{
HXLINE( 344)			HX_VARI( int,_g1) = (int)0;
HXDLIN( 344)			while((_g1 < (int)1024)){
HXLINE( 344)				_g1 = (_g1 + (int)1);
HXLINE( 345)				this->fastHuffman->__unsafe_set((_g1 - (int)1),(int)-1);
            			}
            		}
HXLINE( 348)		HX_VAR( int,len);
HXDLIN( 348)		if (this->sparse) {
HXLINE( 348)			len = this->sortedEntries;
            		}
            		else {
HXLINE( 348)			len = this->entries;
            		}
HXLINE( 353)		{
HXLINE( 353)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 353)			HX_VARI( int,_g) = len;
HXDLIN( 353)			while((_g11 < _g)){
HXLINE( 353)				_g11 = (_g11 + (int)1);
HXDLIN( 353)				HX_VARI( int,i) = (_g11 - (int)1);
HXLINE( 354)				if ((( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) ) <= (int)10)) {
HXLINE( 355)					HX_VAR( int,z);
HXDLIN( 355)					if (this->sparse) {
HXLINE( 355)						HX_VARI( int,n) = this->sortedCodewords->__get(i);
HXDLIN( 355)						n = ((int)hx::UShr(((int)n & (int)(int)-1431655766),(int)1) | (int)((int)((int)n & (int)(int)1431655765) << (int)(int)1));
HXDLIN( 355)						n = ((int)hx::UShr(((int)n & (int)(int)-858993460),(int)2) | (int)((int)((int)n & (int)(int)858993459) << (int)(int)2));
HXDLIN( 355)						n = ((int)hx::UShr(((int)n & (int)(int)-252645136),(int)4) | (int)((int)((int)n & (int)(int)252645135) << (int)(int)4));
HXDLIN( 355)						n = ((int)hx::UShr(((int)n & (int)(int)-16711936),(int)8) | (int)((int)((int)n & (int)(int)16711935) << (int)(int)8));
HXDLIN( 355)						z = ((int)hx::UShr(n,(int)16) | (int)((int)n << (int)(int)16));
            					}
            					else {
HXLINE( 355)						z = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
            					}
HXLINE( 357)					while((z < (int)1024)){
HXLINE( 358)						this->fastHuffman->__unsafe_set(z,i);
HXLINE( 359)						z = (z + ((int)(int)1 << (int)( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) )));
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Codebook_obj,computeAcceleratedHuffman,(void))

bool Codebook_obj::codebookDecode( ::stb::format::vorbis::VorbisDecodeState decodeState,::Array< Float > output,int offset,int len){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_367_codebookDecode)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(output,"output")
            	HX_STACK_ARG(offset,"offset")
            	HX_STACK_ARG(len,"len")
HXLINE( 368)		if ((decodeState->validBits < (int)10)) {
HXLINE( 368)			decodeState->prepHuffman();
            		}
HXDLIN( 368)		HX_VARI( int,i) = ( (int)(_hx_array_unsafe_get(this->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 368)		HX_VAR( int,val);
HXDLIN( 368)		if ((i >= (int)0)) {
HXLINE( 368)			HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 368)			decodeState->acc = hx::UShr(decodeState->acc,l);
HXDLIN( 368)			decodeState->validBits = (decodeState->validBits - l);
HXDLIN( 368)			if ((decodeState->validBits < (int)0)) {
HXLINE( 368)				decodeState->validBits = (int)0;
HXDLIN( 368)				val = (int)-1;
            			}
            			else {
HXLINE( 368)				val = i;
            			}
            		}
            		else {
HXLINE( 368)			val = decodeState->decodeScalarRaw(hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 368)		if (this->sparse) {
HXLINE( 368)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 368)		HX_VARI( int,z) = val;
HXLINE( 369)		HX_VARI( int,lookupValues) = this->lookupValues;
HXLINE( 370)		HX_VARI( bool,sequenceP) = this->sequenceP;
HXLINE( 371)		HX_VARI( ::Array< Float >,multiplicands) = this->multiplicands;
HXLINE( 372)		HX_VARI( Float,minimumValue) = this->minimumValue;
HXLINE( 374)		if ((z < (int)0)) {
HXLINE( 375)			return false;
            		}
HXLINE( 377)		if ((len > this->dimensions)) {
HXLINE( 378)			len = this->dimensions;
            		}
HXLINE( 382)		if ((this->lookupType == (int)1)) {
HXLINE( 383)			HX_VARI( int,div) = (int)1;
HXLINE( 384)			HX_VARI( Float,last) = ((Float)0.0);
HXLINE( 385)			{
HXLINE( 385)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 385)				HX_VARI( int,_g) = len;
HXDLIN( 385)				while((_g1 < _g)){
HXLINE( 385)					_g1 = (_g1 + (int)1);
HXLINE( 386)					HX_VARI_NAME( int,_hx_int,"int") = ::Std_obj::_hx_int(((Float)z / (Float)div));
HXDLIN( 386)					Float off;
HXDLIN( 386)					if ((_hx_int < (int)0)) {
HXLINE( 386)						off = (((Float)4294967296.0) + _hx_int);
            					}
            					else {
HXLINE( 386)						off = (_hx_int + ((Float)0.0));
            					}
HXDLIN( 386)					HX_VARI_NAME( int,int1,"int") = lookupValues;
HXDLIN( 386)					Float off1;
HXDLIN( 386)					if ((int1 < (int)0)) {
HXLINE( 386)						off1 = (((Float)4294967296.0) + int1);
            					}
            					else {
HXLINE( 386)						off1 = (int1 + ((Float)0.0));
            					}
HXLINE( 387)					HX_VARI_NAME( Float,val1,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,::Std_obj::_hx_int(hx::Mod(off,off1)))) ) + last);
HXLINE( 388)					{
HXLINE( 388)						HX_VARI( int,_g2) = (offset + (_g1 - (int)1));
HXDLIN( 388)						{
HXLINE( 388)							Float val2 = (( (Float)(_hx_array_unsafe_get(output,_g2)) ) + val1);
HXDLIN( 388)							output->__unsafe_set(_g2,val2);
            						}
            					}
HXLINE( 389)					if (sequenceP) {
HXLINE( 390)						last = (val1 + minimumValue);
            					}
HXLINE( 392)					div = (div * lookupValues);
            				}
            			}
HXLINE( 394)			return true;
            		}
HXLINE( 397)		z = (z * this->dimensions);
HXLINE( 398)		if (sequenceP) {
HXLINE( 399)			HX_VARI_NAME( Float,last1,"last") = ((Float)0.0);
HXLINE( 400)			{
HXLINE( 400)				HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 400)				HX_VARI_NAME( int,_g3,"_g") = len;
HXDLIN( 400)				while((_g11 < _g3)){
HXLINE( 400)					_g11 = (_g11 + (int)1);
HXDLIN( 400)					HX_VARI_NAME( int,i1,"i") = (_g11 - (int)1);
HXLINE( 401)					HX_VARI_NAME( Float,val3,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i1))) ) + last1);
HXLINE( 402)					{
HXLINE( 402)						HX_VARI_NAME( int,_g21,"_g2") = (offset + i1);
HXDLIN( 402)						{
HXLINE( 402)							Float val4 = (( (Float)(_hx_array_unsafe_get(output,_g21)) ) + val3);
HXDLIN( 402)							output->__unsafe_set(_g21,val4);
            						}
            					}
HXLINE( 403)					last1 = (val3 + minimumValue);
            				}
            			}
            		}
            		else {
HXLINE( 407)			HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN( 407)			HX_VARI_NAME( int,_g4,"_g") = len;
HXDLIN( 407)			while((_g12 < _g4)){
HXLINE( 407)				_g12 = (_g12 + (int)1);
HXDLIN( 407)				HX_VARI_NAME( int,i2,"i") = (_g12 - (int)1);
HXLINE( 408)				{
HXLINE( 408)					HX_VARI_NAME( int,_g22,"_g2") = (offset + i2);
HXDLIN( 408)					{
HXLINE( 408)						HX_VARI_NAME( Float,val5,"val") = ( (Float)(_hx_array_unsafe_get(output,_g22)) );
HXDLIN( 408)						Float val6 = (val5 + ( (Float)(_hx_array_unsafe_get(multiplicands,(z + i2))) ));
HXDLIN( 408)						output->__unsafe_set(_g22,val6);
            					}
            				}
            			}
            		}
HXLINE( 411)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Codebook_obj,codebookDecode,return )

bool Codebook_obj::codebookDecodeStep( ::stb::format::vorbis::VorbisDecodeState decodeState,::Array< Float > output,int offset,int len,int step){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_415_codebookDecodeStep)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(output,"output")
            	HX_STACK_ARG(offset,"offset")
            	HX_STACK_ARG(len,"len")
            	HX_STACK_ARG(step,"step")
HXLINE( 416)		if ((decodeState->validBits < (int)10)) {
HXLINE( 416)			decodeState->prepHuffman();
            		}
HXDLIN( 416)		HX_VARI( int,i) = ( (int)(_hx_array_unsafe_get(this->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 416)		HX_VAR( int,val);
HXDLIN( 416)		if ((i >= (int)0)) {
HXLINE( 416)			HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 416)			decodeState->acc = hx::UShr(decodeState->acc,l);
HXDLIN( 416)			decodeState->validBits = (decodeState->validBits - l);
HXDLIN( 416)			if ((decodeState->validBits < (int)0)) {
HXLINE( 416)				decodeState->validBits = (int)0;
HXDLIN( 416)				val = (int)-1;
            			}
            			else {
HXLINE( 416)				val = i;
            			}
            		}
            		else {
HXLINE( 416)			val = decodeState->decodeScalarRaw(hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 416)		if (this->sparse) {
HXLINE( 416)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 416)		HX_VARI( int,z) = val;
HXLINE( 417)		HX_VARI( Float,last) = ((Float)0.0);
HXLINE( 418)		if ((z < (int)0)) {
HXLINE( 419)			return false;
            		}
HXLINE( 421)		if ((len > this->dimensions)) {
HXLINE( 422)			len = this->dimensions;
            		}
HXLINE( 425)		HX_VARI( int,lookupValues) = this->lookupValues;
HXLINE( 426)		HX_VARI( bool,sequenceP) = this->sequenceP;
HXLINE( 427)		HX_VARI( ::Array< Float >,multiplicands) = this->multiplicands;
HXLINE( 431)		if ((this->lookupType == (int)1)) {
HXLINE( 432)			HX_VARI( int,div) = (int)1;
HXLINE( 433)			{
HXLINE( 433)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 433)				HX_VARI( int,_g) = len;
HXDLIN( 433)				while((_g1 < _g)){
HXLINE( 433)					_g1 = (_g1 + (int)1);
HXLINE( 434)					HX_VARI_NAME( int,_hx_int,"int") = ::Std_obj::_hx_int(((Float)z / (Float)div));
HXDLIN( 434)					Float off;
HXDLIN( 434)					if ((_hx_int < (int)0)) {
HXLINE( 434)						off = (((Float)4294967296.0) + _hx_int);
            					}
            					else {
HXLINE( 434)						off = (_hx_int + ((Float)0.0));
            					}
HXDLIN( 434)					HX_VARI_NAME( int,int1,"int") = lookupValues;
HXDLIN( 434)					Float off1;
HXDLIN( 434)					if ((int1 < (int)0)) {
HXLINE( 434)						off1 = (((Float)4294967296.0) + int1);
            					}
            					else {
HXLINE( 434)						off1 = (int1 + ((Float)0.0));
            					}
HXLINE( 435)					HX_VARI_NAME( Float,val1,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,::Std_obj::_hx_int(hx::Mod(off,off1)))) ) + last);
HXLINE( 436)					{
HXLINE( 436)						HX_VARI( int,_g2) = (offset + ((_g1 - (int)1) * step));
HXDLIN( 436)						{
HXLINE( 436)							Float val2 = (( (Float)(_hx_array_unsafe_get(output,_g2)) ) + val1);
HXDLIN( 436)							output->__unsafe_set(_g2,val2);
            						}
            					}
HXLINE( 437)					if (sequenceP) {
HXLINE( 438)						last = val1;
            					}
HXLINE( 440)					div = (div * lookupValues);
            				}
            			}
HXLINE( 442)			return true;
            		}
HXLINE( 445)		z = (z * this->dimensions);
HXLINE( 446)		{
HXLINE( 446)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 446)			HX_VARI_NAME( int,_g3,"_g") = len;
HXDLIN( 446)			while((_g11 < _g3)){
HXLINE( 446)				_g11 = (_g11 + (int)1);
HXDLIN( 446)				HX_VARI_NAME( int,i1,"i") = (_g11 - (int)1);
HXLINE( 447)				HX_VARI_NAME( Float,val3,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i1))) ) + last);
HXLINE( 448)				{
HXLINE( 448)					HX_VARI_NAME( int,_g21,"_g2") = (offset + (i1 * step));
HXDLIN( 448)					{
HXLINE( 448)						Float val4 = (( (Float)(_hx_array_unsafe_get(output,_g21)) ) + val3);
HXDLIN( 448)						output->__unsafe_set(_g21,val4);
            					}
            				}
HXLINE( 449)				if (sequenceP) {
HXLINE( 450)					last = val3;
            				}
            			}
            		}
HXLINE( 454)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,codebookDecodeStep,return )

int Codebook_obj::decodeStart( ::stb::format::vorbis::VorbisDecodeState decodeState){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_459_decodeStart)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
HXLINE( 459)		if ((decodeState->validBits < (int)10)) {
HXLINE( 459)			decodeState->prepHuffman();
            		}
HXDLIN( 459)		HX_VARI( int,i) = ( (int)(_hx_array_unsafe_get(this->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 459)		HX_VAR( int,val);
HXDLIN( 459)		if ((i >= (int)0)) {
HXLINE( 459)			HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 459)			decodeState->acc = hx::UShr(decodeState->acc,l);
HXDLIN( 459)			decodeState->validBits = (decodeState->validBits - l);
HXDLIN( 459)			if ((decodeState->validBits < (int)0)) {
HXLINE( 459)				decodeState->validBits = (int)0;
HXDLIN( 459)				val = (int)-1;
            			}
            			else {
HXLINE( 459)				val = i;
            			}
            		}
            		else {
HXLINE( 459)			val = decodeState->decodeScalarRaw(hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 459)		if (this->sparse) {
HXLINE( 459)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 459)		return val;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,decodeStart,return )

 ::Dynamic Codebook_obj::decodeDeinterleaveRepeat( ::stb::format::vorbis::VorbisDecodeState decodeState,::Array< ::Dynamic> residueBuffers,int ch,int cInter,int pInter,int len,int totalDecode){
            	HX_GC_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_483_decodeDeinterleaveRepeat)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(residueBuffers,"residueBuffers")
            	HX_STACK_ARG(ch,"ch")
            	HX_STACK_ARG(cInter,"cInter")
            	HX_STACK_ARG(pInter,"pInter")
            	HX_STACK_ARG(len,"len")
            	HX_STACK_ARG(totalDecode,"totalDecode")
HXLINE( 484)		HX_VARI( int,effective) = this->dimensions;
HXLINE( 487)		if ((this->lookupType == (int)0)) {
HXLINE( 488)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_STREAM_dyn(),null(),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),488,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("decodeDeinterleaveRepeat",65,00,32,3c))));
            		}
HXLINE( 491)		HX_VARI( ::Array< Float >,multiplicands) = this->multiplicands;
HXLINE( 492)		HX_VARI( bool,sequenceP) = this->sequenceP;
HXLINE( 493)		HX_VARI( int,lookupValues) = this->lookupValues;
HXLINE( 495)		while((totalDecode > (int)0)){
HXLINE( 496)			HX_VARI( Float,last) = ((Float)0.0);
HXLINE( 497)			if ((decodeState->validBits < (int)10)) {
HXLINE( 497)				decodeState->prepHuffman();
            			}
HXDLIN( 497)			HX_VARI( int,i) = ( (int)(_hx_array_unsafe_get(this->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 497)			HX_VAR( int,val);
HXDLIN( 497)			if ((i >= (int)0)) {
HXLINE( 497)				HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 497)				decodeState->acc = hx::UShr(decodeState->acc,l);
HXDLIN( 497)				decodeState->validBits = (decodeState->validBits - l);
HXDLIN( 497)				if ((decodeState->validBits < (int)0)) {
HXLINE( 497)					decodeState->validBits = (int)0;
HXDLIN( 497)					val = (int)-1;
            				}
            				else {
HXLINE( 497)					val = i;
            				}
            			}
            			else {
HXLINE( 497)				val = decodeState->decodeScalarRaw(hx::ObjectPtr<OBJ_>(this));
            			}
HXDLIN( 497)			if (this->sparse) {
HXLINE( 497)				val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            			}
HXDLIN( 497)			HX_VARI( int,z) = val;
HXLINE( 499)			if ((z < (int)0)) {
HXLINE( 500)				bool _hx_tmp;
HXDLIN( 500)				if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 500)					_hx_tmp = decodeState->lastSeg;
            				}
            				else {
HXLINE( 500)					_hx_tmp = false;
            				}
HXDLIN( 500)				if (_hx_tmp) {
HXLINE( 501)					return null();
            				}
HXLINE( 503)				HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_STREAM_dyn(),null(),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),503,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("decodeDeinterleaveRepeat",65,00,32,3c))));
            			}
HXLINE( 510)			if ((((cInter + (pInter * ch)) + effective) > (len * ch))) {
HXLINE( 511)				effective = ((len * ch) - ((pInter * ch) - cInter));
            			}
HXLINE( 514)			if ((this->lookupType == (int)1)) {
HXLINE( 515)				HX_VARI( int,div) = (int)1;
HXLINE( 516)				if (sequenceP) {
HXLINE( 517)					HX_VARI( int,_g1) = (int)0;
HXDLIN( 517)					HX_VARI( int,_g) = effective;
HXDLIN( 517)					while((_g1 < _g)){
HXLINE( 517)						_g1 = (_g1 + (int)1);
HXLINE( 518)						HX_VARI_NAME( int,_hx_int,"int") = ::Std_obj::_hx_int(((Float)z / (Float)div));
HXDLIN( 518)						Float off;
HXDLIN( 518)						if ((_hx_int < (int)0)) {
HXLINE( 518)							off = (((Float)4294967296.0) + _hx_int);
            						}
            						else {
HXLINE( 518)							off = (_hx_int + ((Float)0.0));
            						}
HXDLIN( 518)						HX_VARI_NAME( int,int1,"int") = lookupValues;
HXDLIN( 518)						Float off1;
HXDLIN( 518)						if ((int1 < (int)0)) {
HXLINE( 518)							off1 = (((Float)4294967296.0) + int1);
            						}
            						else {
HXLINE( 518)							off1 = (int1 + ((Float)0.0));
            						}
HXLINE( 519)						HX_VARI_NAME( Float,val1,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,::Std_obj::_hx_int(hx::Mod(off,off1)))) ) + last);
HXLINE( 520)						{
HXLINE( 520)							HX_VARI( int,_g2) = pInter;
HXDLIN( 520)							{
HXLINE( 520)								::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 520)								Float val2 = (( (Float)(_hx_array_unsafe_get(( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) ),_g2)) ) + val1);
HXDLIN( 520)								this1->__unsafe_set(_g2,val2);
            							}
            						}
HXLINE( 521)						cInter = (cInter + (int)1);
HXDLIN( 521)						if ((cInter == ch)) {
HXLINE( 522)							cInter = (int)0;
HXLINE( 523)							pInter = (pInter + (int)1);
            						}
HXLINE( 525)						last = val1;
HXLINE( 526)						div = (div * lookupValues);
            					}
            				}
            				else {
HXLINE( 529)					HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 529)					HX_VARI_NAME( int,_g3,"_g") = effective;
HXDLIN( 529)					while((_g11 < _g3)){
HXLINE( 529)						_g11 = (_g11 + (int)1);
HXLINE( 530)						HX_VARI_NAME( int,int2,"int") = ::Std_obj::_hx_int(((Float)z / (Float)div));
HXDLIN( 530)						Float off2;
HXDLIN( 530)						if ((int2 < (int)0)) {
HXLINE( 530)							off2 = (((Float)4294967296.0) + int2);
            						}
            						else {
HXLINE( 530)							off2 = (int2 + ((Float)0.0));
            						}
HXDLIN( 530)						HX_VARI_NAME( int,int3,"int") = lookupValues;
HXDLIN( 530)						Float off3;
HXDLIN( 530)						if ((int3 < (int)0)) {
HXLINE( 530)							off3 = (((Float)4294967296.0) + int3);
            						}
            						else {
HXLINE( 530)							off3 = (int3 + ((Float)0.0));
            						}
HXLINE( 531)						HX_VARI_NAME( Float,val3,"val") = ( (Float)(_hx_array_unsafe_get(multiplicands,::Std_obj::_hx_int(hx::Mod(off2,off3)))) );
HXLINE( 532)						{
HXLINE( 532)							HX_VARI_NAME( int,_g21,"_g2") = pInter;
HXDLIN( 532)							{
HXLINE( 532)								::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 532)								Float val4 = (( (Float)(_hx_array_unsafe_get(( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) ),_g21)) ) + val3);
HXDLIN( 532)								this2->__unsafe_set(_g21,val4);
            							}
            						}
HXLINE( 533)						cInter = (cInter + (int)1);
HXDLIN( 533)						if ((cInter == ch)) {
HXLINE( 534)							cInter = (int)0;
HXLINE( 535)							pInter = (pInter + (int)1);
            						}
HXLINE( 537)						div = (div * lookupValues);
            					}
            				}
            			}
            			else {
HXLINE( 541)				z = (z * this->dimensions);
HXLINE( 542)				if (sequenceP) {
HXLINE( 543)					HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN( 543)					HX_VARI_NAME( int,_g4,"_g") = effective;
HXDLIN( 543)					while((_g12 < _g4)){
HXLINE( 543)						_g12 = (_g12 + (int)1);
HXLINE( 544)						HX_VARI_NAME( Float,val5,"val") = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + (_g12 - (int)1)))) ) + last);
HXLINE( 545)						{
HXLINE( 545)							HX_VARI_NAME( int,_g22,"_g2") = pInter;
HXDLIN( 545)							{
HXLINE( 545)								::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 545)								Float val6 = (( (Float)(_hx_array_unsafe_get(( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) ),_g22)) ) + val5);
HXDLIN( 545)								this3->__unsafe_set(_g22,val6);
            							}
            						}
HXLINE( 546)						cInter = (cInter + (int)1);
HXDLIN( 546)						if ((cInter == ch)) {
HXLINE( 547)							cInter = (int)0;
HXLINE( 548)							pInter = (pInter + (int)1);
            						}
HXLINE( 550)						last = val5;
            					}
            				}
            				else {
HXLINE( 553)					HX_VARI_NAME( int,_g13,"_g1") = (int)0;
HXDLIN( 553)					HX_VARI_NAME( int,_g5,"_g") = effective;
HXDLIN( 553)					while((_g13 < _g5)){
HXLINE( 553)						_g13 = (_g13 + (int)1);
HXLINE( 554)						HX_VARI_NAME( Float,val7,"val") = ( (Float)(_hx_array_unsafe_get(multiplicands,(z + (_g13 - (int)1)))) );
HXLINE( 555)						{
HXLINE( 555)							HX_VARI_NAME( int,_g23,"_g2") = pInter;
HXDLIN( 555)							{
HXLINE( 555)								::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 555)								Float val8 = (( (Float)(_hx_array_unsafe_get(( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) ),_g23)) ) + val7);
HXDLIN( 555)								this4->__unsafe_set(_g23,val8);
            							}
            						}
HXLINE( 556)						cInter = (cInter + (int)1);
HXDLIN( 556)						if ((cInter == ch)) {
HXLINE( 557)							cInter = (int)0;
HXLINE( 558)							pInter = (pInter + (int)1);
            						}
            					}
            				}
            			}
HXLINE( 564)			totalDecode = (totalDecode - effective);
            		}
HXLINE( 567)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("cInter",b9,e7,a2,e6),cInter)
            			->setFixed(1,HX_("pInter",8c,98,46,19),pInter));
            	}


HX_DEFINE_DYNAMIC_FUNC7(Codebook_obj,decodeDeinterleaveRepeat,return )

bool Codebook_obj::residueDecode( ::stb::format::vorbis::VorbisDecodeState decodeState,::Array< Float > target,int offset,int n,int rtype){
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_574_residueDecode)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(target,"target")
            	HX_STACK_ARG(offset,"offset")
            	HX_STACK_ARG(n,"n")
            	HX_STACK_ARG(rtype,"rtype")
HXLINE( 575)		if ((rtype == (int)0)) {
HXLINE( 576)			HX_VARI( int,step) = ::Std_obj::_hx_int(((Float)n / (Float)this->dimensions));
HXLINE( 577)			{
HXLINE( 577)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 577)				while((_g1 < step)){
HXLINE( 577)					_g1 = (_g1 + (int)1);
HXDLIN( 577)					HX_VARI( int,k) = (_g1 - (int)1);
HXLINE( 578)					if (!(this->codebookDecodeStep(decodeState,target,(offset + k),((n - offset) - k),step))) {
HXLINE( 579)						return false;
            					}
            				}
            			}
            		}
            		else {
HXLINE( 583)			HX_VARI_NAME( int,k1,"k") = (int)0;
HXLINE( 584)			while((k1 < n)){
HXLINE( 585)				if (!(this->codebookDecode(decodeState,target,offset,(n - k1)))) {
HXLINE( 586)					return false;
            				}
HXLINE( 588)				k1 = (k1 + this->dimensions);
HXLINE( 589)				offset = (offset + this->dimensions);
            			}
            		}
HXLINE( 592)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,residueDecode,return )

int Codebook_obj::NO_CODE;

 ::stb::format::vorbis::data::Codebook Codebook_obj::read( ::stb::format::vorbis::VorbisDecodeState decodeState){
            	HX_GC_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_37_read)
            	HX_STACK_ARG(decodeState,"decodeState")
HXLINE(  38)		HX_VARI(  ::stb::format::vorbis::data::Codebook,c) =  ::stb::format::vorbis::data::Codebook_obj::__alloc( HX_CTX );
HXLINE(  39)		bool _hx_tmp;
HXDLIN(  39)		bool _hx_tmp1;
HXDLIN(  39)		int _hx_tmp2;
HXDLIN(  39)		if ((decodeState->validBits < (int)0)) {
HXLINE(  39)			_hx_tmp2 = (int)0;
            		}
            		else {
HXLINE(  39)			if ((decodeState->validBits < (int)8)) {
HXLINE(  39)				if ((decodeState->validBits == (int)0)) {
HXLINE(  39)					decodeState->acc = (int)0;
            				}
HXDLIN(  39)				while(true){
HXLINE(  39)					bool _hx_tmp3;
HXDLIN(  39)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  39)						if (!(decodeState->lastSeg)) {
HXLINE(  39)							_hx_tmp3 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  39)							_hx_tmp3 = true;
            						}
            					}
            					else {
HXLINE(  39)						_hx_tmp3 = false;
            					}
HXDLIN(  39)					if (_hx_tmp3) {
HXLINE(  39)						decodeState->validBits = (int)-1;
HXDLIN(  39)						goto _hx_goto_36;
            					}
            					else {
HXLINE(  39)						decodeState->bytesInSeg--;
HXDLIN(  39)						int a = decodeState->acc;
HXDLIN(  39)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  39)						int b = decodeState->input->readByte();
HXDLIN(  39)						decodeState->acc = (a + ((int)b << (int)decodeState->validBits));
HXDLIN(  39)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  39)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  39)						goto _hx_goto_36;
            					}
            				}
            				_hx_goto_36:;
HXDLIN(  39)				if ((decodeState->validBits < (int)0)) {
HXLINE(  39)					_hx_tmp2 = (int)0;
            				}
            				else {
HXLINE(  39)					HX_VARI( int,z) = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)					_hx_tmp2 = z;
            				}
            			}
            			else {
HXLINE(  39)				HX_VARI_NAME( int,z1,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)				_hx_tmp2 = z1;
            			}
            		}
HXDLIN(  39)		if ((_hx_tmp2 == (int)66)) {
HXLINE(  39)			int _hx_tmp4;
HXDLIN(  39)			if ((decodeState->validBits < (int)0)) {
HXLINE(  39)				_hx_tmp4 = (int)0;
            			}
            			else {
HXLINE(  39)				if ((decodeState->validBits < (int)8)) {
HXLINE(  39)					if ((decodeState->validBits == (int)0)) {
HXLINE(  39)						decodeState->acc = (int)0;
            					}
HXDLIN(  39)					while(true){
HXLINE(  39)						bool _hx_tmp5;
HXDLIN(  39)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  39)							if (!(decodeState->lastSeg)) {
HXLINE(  39)								_hx_tmp5 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE(  39)								_hx_tmp5 = true;
            							}
            						}
            						else {
HXLINE(  39)							_hx_tmp5 = false;
            						}
HXDLIN(  39)						if (_hx_tmp5) {
HXLINE(  39)							decodeState->validBits = (int)-1;
HXDLIN(  39)							goto _hx_goto_37;
            						}
            						else {
HXLINE(  39)							decodeState->bytesInSeg--;
HXDLIN(  39)							int a1 = decodeState->acc;
HXDLIN(  39)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  39)							int b1 = decodeState->input->readByte();
HXDLIN(  39)							decodeState->acc = (a1 + ((int)b1 << (int)decodeState->validBits));
HXDLIN(  39)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN(  39)						if (!((decodeState->validBits < (int)8))) {
HXLINE(  39)							goto _hx_goto_37;
            						}
            					}
            					_hx_goto_37:;
HXDLIN(  39)					if ((decodeState->validBits < (int)0)) {
HXLINE(  39)						_hx_tmp4 = (int)0;
            					}
            					else {
HXLINE(  39)						HX_VARI_NAME( int,z2,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)						decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)						decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)						_hx_tmp4 = z2;
            					}
            				}
            				else {
HXLINE(  39)					HX_VARI_NAME( int,z3,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)					_hx_tmp4 = z3;
            				}
            			}
HXDLIN(  39)			_hx_tmp1 = (_hx_tmp4 != (int)67);
            		}
            		else {
HXLINE(  39)			_hx_tmp1 = true;
            		}
HXDLIN(  39)		if (!(_hx_tmp1)) {
HXLINE(  39)			int _hx_tmp6;
HXDLIN(  39)			if ((decodeState->validBits < (int)0)) {
HXLINE(  39)				_hx_tmp6 = (int)0;
            			}
            			else {
HXLINE(  39)				if ((decodeState->validBits < (int)8)) {
HXLINE(  39)					if ((decodeState->validBits == (int)0)) {
HXLINE(  39)						decodeState->acc = (int)0;
            					}
HXDLIN(  39)					while(true){
HXLINE(  39)						bool _hx_tmp7;
HXDLIN(  39)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  39)							if (!(decodeState->lastSeg)) {
HXLINE(  39)								_hx_tmp7 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE(  39)								_hx_tmp7 = true;
            							}
            						}
            						else {
HXLINE(  39)							_hx_tmp7 = false;
            						}
HXDLIN(  39)						if (_hx_tmp7) {
HXLINE(  39)							decodeState->validBits = (int)-1;
HXDLIN(  39)							goto _hx_goto_38;
            						}
            						else {
HXLINE(  39)							decodeState->bytesInSeg--;
HXDLIN(  39)							int a2 = decodeState->acc;
HXDLIN(  39)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  39)							int b2 = decodeState->input->readByte();
HXDLIN(  39)							decodeState->acc = (a2 + ((int)b2 << (int)decodeState->validBits));
HXDLIN(  39)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN(  39)						if (!((decodeState->validBits < (int)8))) {
HXLINE(  39)							goto _hx_goto_38;
            						}
            					}
            					_hx_goto_38:;
HXDLIN(  39)					if ((decodeState->validBits < (int)0)) {
HXLINE(  39)						_hx_tmp6 = (int)0;
            					}
            					else {
HXLINE(  39)						HX_VARI_NAME( int,z4,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)						decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)						decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)						_hx_tmp6 = z4;
            					}
            				}
            				else {
HXLINE(  39)					HX_VARI_NAME( int,z5,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  39)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  39)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  39)					_hx_tmp6 = z5;
            				}
            			}
HXDLIN(  39)			_hx_tmp = (_hx_tmp6 != (int)86);
            		}
            		else {
HXLINE(  39)			_hx_tmp = true;
            		}
HXDLIN(  39)		if (_hx_tmp) {
HXLINE(  40)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),40,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  43)		HX_VAR( int,x);
HXDLIN(  43)		if ((decodeState->validBits < (int)0)) {
HXLINE(  43)			x = (int)0;
            		}
            		else {
HXLINE(  43)			if ((decodeState->validBits < (int)8)) {
HXLINE(  43)				if ((decodeState->validBits == (int)0)) {
HXLINE(  43)					decodeState->acc = (int)0;
            				}
HXDLIN(  43)				while(true){
HXLINE(  43)					bool x1;
HXDLIN(  43)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  43)						if (!(decodeState->lastSeg)) {
HXLINE(  43)							x1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  43)							x1 = true;
            						}
            					}
            					else {
HXLINE(  43)						x1 = false;
            					}
HXDLIN(  43)					if (x1) {
HXLINE(  43)						decodeState->validBits = (int)-1;
HXDLIN(  43)						goto _hx_goto_39;
            					}
            					else {
HXLINE(  43)						decodeState->bytesInSeg--;
HXDLIN(  43)						int a3 = decodeState->acc;
HXDLIN(  43)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  43)						int b3 = decodeState->input->readByte();
HXDLIN(  43)						decodeState->acc = (a3 + ((int)b3 << (int)decodeState->validBits));
HXDLIN(  43)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  43)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  43)						goto _hx_goto_39;
            					}
            				}
            				_hx_goto_39:;
HXDLIN(  43)				if ((decodeState->validBits < (int)0)) {
HXLINE(  43)					x = (int)0;
            				}
            				else {
HXLINE(  43)					HX_VARI_NAME( int,z6,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  43)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  43)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  43)					x = z6;
            				}
            			}
            			else {
HXLINE(  43)				HX_VARI_NAME( int,z7,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  43)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  43)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  43)				x = z7;
            			}
            		}
HXLINE(  44)		int _hx_tmp8;
HXDLIN(  44)		if ((decodeState->validBits < (int)0)) {
HXLINE(  44)			_hx_tmp8 = (int)0;
            		}
            		else {
HXLINE(  44)			if ((decodeState->validBits < (int)8)) {
HXLINE(  44)				if ((decodeState->validBits == (int)0)) {
HXLINE(  44)					decodeState->acc = (int)0;
            				}
HXDLIN(  44)				while(true){
HXLINE(  44)					bool _hx_tmp9;
HXDLIN(  44)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  44)						if (!(decodeState->lastSeg)) {
HXLINE(  44)							_hx_tmp9 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  44)							_hx_tmp9 = true;
            						}
            					}
            					else {
HXLINE(  44)						_hx_tmp9 = false;
            					}
HXDLIN(  44)					if (_hx_tmp9) {
HXLINE(  44)						decodeState->validBits = (int)-1;
HXDLIN(  44)						goto _hx_goto_40;
            					}
            					else {
HXLINE(  44)						decodeState->bytesInSeg--;
HXDLIN(  44)						int a4 = decodeState->acc;
HXDLIN(  44)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  44)						int b4 = decodeState->input->readByte();
HXDLIN(  44)						decodeState->acc = (a4 + ((int)b4 << (int)decodeState->validBits));
HXDLIN(  44)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  44)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  44)						goto _hx_goto_40;
            					}
            				}
            				_hx_goto_40:;
HXDLIN(  44)				if ((decodeState->validBits < (int)0)) {
HXLINE(  44)					_hx_tmp8 = (int)0;
            				}
            				else {
HXLINE(  44)					HX_VARI_NAME( int,z8,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  44)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  44)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  44)					_hx_tmp8 = z8;
            				}
            			}
            			else {
HXLINE(  44)				HX_VARI_NAME( int,z9,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  44)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  44)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  44)				_hx_tmp8 = z9;
            			}
            		}
HXDLIN(  44)		c->dimensions = (((int)_hx_tmp8 << (int)(int)8) + x);
HXLINE(  46)		HX_VAR_NAME( int,x2,"x");
HXDLIN(  46)		if ((decodeState->validBits < (int)0)) {
HXLINE(  46)			x2 = (int)0;
            		}
            		else {
HXLINE(  46)			if ((decodeState->validBits < (int)8)) {
HXLINE(  46)				if ((decodeState->validBits == (int)0)) {
HXLINE(  46)					decodeState->acc = (int)0;
            				}
HXDLIN(  46)				while(true){
HXLINE(  46)					bool x3;
HXDLIN(  46)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  46)						if (!(decodeState->lastSeg)) {
HXLINE(  46)							x3 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  46)							x3 = true;
            						}
            					}
            					else {
HXLINE(  46)						x3 = false;
            					}
HXDLIN(  46)					if (x3) {
HXLINE(  46)						decodeState->validBits = (int)-1;
HXDLIN(  46)						goto _hx_goto_41;
            					}
            					else {
HXLINE(  46)						decodeState->bytesInSeg--;
HXDLIN(  46)						int a5 = decodeState->acc;
HXDLIN(  46)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  46)						int b5 = decodeState->input->readByte();
HXDLIN(  46)						decodeState->acc = (a5 + ((int)b5 << (int)decodeState->validBits));
HXDLIN(  46)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  46)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  46)						goto _hx_goto_41;
            					}
            				}
            				_hx_goto_41:;
HXDLIN(  46)				if ((decodeState->validBits < (int)0)) {
HXLINE(  46)					x2 = (int)0;
            				}
            				else {
HXLINE(  46)					HX_VARI_NAME( int,z10,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  46)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  46)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  46)					x2 = z10;
            				}
            			}
            			else {
HXLINE(  46)				HX_VARI_NAME( int,z11,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  46)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  46)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  46)				x2 = z11;
            			}
            		}
HXLINE(  47)		HX_VAR( int,y);
HXDLIN(  47)		if ((decodeState->validBits < (int)0)) {
HXLINE(  47)			y = (int)0;
            		}
            		else {
HXLINE(  47)			if ((decodeState->validBits < (int)8)) {
HXLINE(  47)				if ((decodeState->validBits == (int)0)) {
HXLINE(  47)					decodeState->acc = (int)0;
            				}
HXDLIN(  47)				while(true){
HXLINE(  47)					bool y1;
HXDLIN(  47)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  47)						if (!(decodeState->lastSeg)) {
HXLINE(  47)							y1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  47)							y1 = true;
            						}
            					}
            					else {
HXLINE(  47)						y1 = false;
            					}
HXDLIN(  47)					if (y1) {
HXLINE(  47)						decodeState->validBits = (int)-1;
HXDLIN(  47)						goto _hx_goto_42;
            					}
            					else {
HXLINE(  47)						decodeState->bytesInSeg--;
HXDLIN(  47)						int a6 = decodeState->acc;
HXDLIN(  47)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  47)						int b6 = decodeState->input->readByte();
HXDLIN(  47)						decodeState->acc = (a6 + ((int)b6 << (int)decodeState->validBits));
HXDLIN(  47)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  47)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  47)						goto _hx_goto_42;
            					}
            				}
            				_hx_goto_42:;
HXDLIN(  47)				if ((decodeState->validBits < (int)0)) {
HXLINE(  47)					y = (int)0;
            				}
            				else {
HXLINE(  47)					HX_VARI_NAME( int,z12,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  47)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  47)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  47)					y = z12;
            				}
            			}
            			else {
HXLINE(  47)				HX_VARI_NAME( int,z13,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  47)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  47)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  47)				y = z13;
            			}
            		}
HXLINE(  48)		int _hx_tmp10;
HXDLIN(  48)		if ((decodeState->validBits < (int)0)) {
HXLINE(  48)			_hx_tmp10 = (int)0;
            		}
            		else {
HXLINE(  48)			if ((decodeState->validBits < (int)8)) {
HXLINE(  48)				if ((decodeState->validBits == (int)0)) {
HXLINE(  48)					decodeState->acc = (int)0;
            				}
HXDLIN(  48)				while(true){
HXLINE(  48)					bool _hx_tmp11;
HXDLIN(  48)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  48)						if (!(decodeState->lastSeg)) {
HXLINE(  48)							_hx_tmp11 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  48)							_hx_tmp11 = true;
            						}
            					}
            					else {
HXLINE(  48)						_hx_tmp11 = false;
            					}
HXDLIN(  48)					if (_hx_tmp11) {
HXLINE(  48)						decodeState->validBits = (int)-1;
HXDLIN(  48)						goto _hx_goto_43;
            					}
            					else {
HXLINE(  48)						decodeState->bytesInSeg--;
HXDLIN(  48)						int a7 = decodeState->acc;
HXDLIN(  48)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  48)						int b7 = decodeState->input->readByte();
HXDLIN(  48)						decodeState->acc = (a7 + ((int)b7 << (int)decodeState->validBits));
HXDLIN(  48)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  48)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  48)						goto _hx_goto_43;
            					}
            				}
            				_hx_goto_43:;
HXDLIN(  48)				if ((decodeState->validBits < (int)0)) {
HXLINE(  48)					_hx_tmp10 = (int)0;
            				}
            				else {
HXLINE(  48)					HX_VARI_NAME( int,z14,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  48)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  48)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  48)					_hx_tmp10 = z14;
            				}
            			}
            			else {
HXLINE(  48)				HX_VARI_NAME( int,z15,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  48)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  48)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  48)				_hx_tmp10 = z15;
            			}
            		}
HXDLIN(  48)		c->entries = ((((int)_hx_tmp10 << (int)(int)16) + ((int)y << (int)(int)8)) + x2);
HXLINE(  49)		HX_VAR( int,ordered);
HXDLIN(  49)		if ((decodeState->validBits < (int)0)) {
HXLINE(  49)			ordered = (int)0;
            		}
            		else {
HXLINE(  49)			if ((decodeState->validBits < (int)1)) {
HXLINE(  49)				if ((decodeState->validBits == (int)0)) {
HXLINE(  49)					decodeState->acc = (int)0;
            				}
HXDLIN(  49)				while(true){
HXLINE(  49)					bool ordered1;
HXDLIN(  49)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  49)						if (!(decodeState->lastSeg)) {
HXLINE(  49)							ordered1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  49)							ordered1 = true;
            						}
            					}
            					else {
HXLINE(  49)						ordered1 = false;
            					}
HXDLIN(  49)					if (ordered1) {
HXLINE(  49)						decodeState->validBits = (int)-1;
HXDLIN(  49)						goto _hx_goto_44;
            					}
            					else {
HXLINE(  49)						decodeState->bytesInSeg--;
HXDLIN(  49)						int a8 = decodeState->acc;
HXDLIN(  49)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  49)						int b8 = decodeState->input->readByte();
HXDLIN(  49)						decodeState->acc = (a8 + ((int)b8 << (int)decodeState->validBits));
HXDLIN(  49)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  49)					if (!((decodeState->validBits < (int)1))) {
HXLINE(  49)						goto _hx_goto_44;
            					}
            				}
            				_hx_goto_44:;
HXDLIN(  49)				if ((decodeState->validBits < (int)0)) {
HXLINE(  49)					ordered = (int)0;
            				}
            				else {
HXLINE(  49)					HX_VARI_NAME( int,z16,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  49)					decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  49)					decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  49)					ordered = z16;
            				}
            			}
            			else {
HXLINE(  49)				HX_VARI_NAME( int,z17,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  49)				decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  49)				decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  49)				ordered = z17;
            			}
            		}
HXLINE(  50)		bool _hx_tmp12;
HXDLIN(  50)		if ((ordered != (int)0)) {
HXLINE(  50)			_hx_tmp12 = false;
            		}
            		else {
HXLINE(  50)			int _hx_tmp13;
HXDLIN(  50)			if ((decodeState->validBits < (int)0)) {
HXLINE(  50)				_hx_tmp13 = (int)0;
            			}
            			else {
HXLINE(  50)				if ((decodeState->validBits < (int)1)) {
HXLINE(  50)					if ((decodeState->validBits == (int)0)) {
HXLINE(  50)						decodeState->acc = (int)0;
            					}
HXDLIN(  50)					while(true){
HXLINE(  50)						bool _hx_tmp14;
HXDLIN(  50)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  50)							if (!(decodeState->lastSeg)) {
HXLINE(  50)								_hx_tmp14 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE(  50)								_hx_tmp14 = true;
            							}
            						}
            						else {
HXLINE(  50)							_hx_tmp14 = false;
            						}
HXDLIN(  50)						if (_hx_tmp14) {
HXLINE(  50)							decodeState->validBits = (int)-1;
HXDLIN(  50)							goto _hx_goto_45;
            						}
            						else {
HXLINE(  50)							decodeState->bytesInSeg--;
HXDLIN(  50)							int a9 = decodeState->acc;
HXDLIN(  50)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  50)							int b9 = decodeState->input->readByte();
HXDLIN(  50)							decodeState->acc = (a9 + ((int)b9 << (int)decodeState->validBits));
HXDLIN(  50)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN(  50)						if (!((decodeState->validBits < (int)1))) {
HXLINE(  50)							goto _hx_goto_45;
            						}
            					}
            					_hx_goto_45:;
HXDLIN(  50)					if ((decodeState->validBits < (int)0)) {
HXLINE(  50)						_hx_tmp13 = (int)0;
            					}
            					else {
HXLINE(  50)						HX_VARI_NAME( int,z18,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  50)						decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  50)						decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  50)						_hx_tmp13 = z18;
            					}
            				}
            				else {
HXLINE(  50)					HX_VARI_NAME( int,z19,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  50)					decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  50)					decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  50)					_hx_tmp13 = z19;
            				}
            			}
HXDLIN(  50)			_hx_tmp12 = (_hx_tmp13 != (int)0);
            		}
HXDLIN(  50)		c->sparse = _hx_tmp12;
HXLINE(  52)		HX_VARI( ::Array< int >,lengths) = ::Array_obj< int >::__new(c->entries);
HXLINE(  53)		if (!(c->sparse)) {
HXLINE(  54)			c->codewordLengths = lengths;
            		}
HXLINE(  57)		HX_VARI( int,total) = (int)0;
HXLINE(  59)		if ((ordered != (int)0)) {
HXLINE(  60)			HX_VARI( int,currentEntry) = (int)0;
HXLINE(  61)			int currentLength;
HXDLIN(  61)			if ((decodeState->validBits < (int)0)) {
HXLINE(  61)				currentLength = (int)0;
            			}
            			else {
HXLINE(  61)				if ((decodeState->validBits < (int)5)) {
HXLINE(  61)					if ((decodeState->validBits == (int)0)) {
HXLINE(  61)						decodeState->acc = (int)0;
            					}
HXDLIN(  61)					while(true){
HXLINE(  61)						bool currentLength1;
HXDLIN(  61)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  61)							if (!(decodeState->lastSeg)) {
HXLINE(  61)								currentLength1 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE(  61)								currentLength1 = true;
            							}
            						}
            						else {
HXLINE(  61)							currentLength1 = false;
            						}
HXDLIN(  61)						if (currentLength1) {
HXLINE(  61)							decodeState->validBits = (int)-1;
HXDLIN(  61)							goto _hx_goto_46;
            						}
            						else {
HXLINE(  61)							decodeState->bytesInSeg--;
HXDLIN(  61)							int a10 = decodeState->acc;
HXDLIN(  61)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  61)							int b10 = decodeState->input->readByte();
HXDLIN(  61)							decodeState->acc = (a10 + ((int)b10 << (int)decodeState->validBits));
HXDLIN(  61)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN(  61)						if (!((decodeState->validBits < (int)5))) {
HXLINE(  61)							goto _hx_goto_46;
            						}
            					}
            					_hx_goto_46:;
HXDLIN(  61)					if ((decodeState->validBits < (int)0)) {
HXLINE(  61)						currentLength = (int)0;
            					}
            					else {
HXLINE(  61)						HX_VARI_NAME( int,z20,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  61)						decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  61)						decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  61)						currentLength = z20;
            					}
            				}
            				else {
HXLINE(  61)					HX_VARI_NAME( int,z21,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  61)					decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  61)					decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  61)					currentLength = z21;
            				}
            			}
HXDLIN(  61)			HX_VARI_NAME( int,currentLength2,"currentLength") = (currentLength + (int)1);
HXLINE(  63)			while((currentEntry < c->entries)){
HXLINE(  64)				HX_VARI( int,limit) = (c->entries - currentEntry);
HXLINE(  65)				HX_VARI( ::Array< int >,log2_4) = ::Array_obj< int >::fromData( _hx_array_data_19459da9_62,16);
HXDLIN(  65)				HX_VAR( int,n);
HXDLIN(  65)				if ((limit < (int)16384)) {
HXLINE(  65)					if ((limit < (int)16)) {
HXLINE(  65)						n = log2_4->__get(limit);
            					}
            					else {
HXLINE(  65)						if ((limit < (int)512)) {
HXLINE(  65)							n = ((int)5 + log2_4->__get(((int)limit >> (int)(int)5)));
            						}
            						else {
HXLINE(  65)							n = ((int)10 + log2_4->__get(((int)limit >> (int)(int)10)));
            						}
            					}
            				}
            				else {
HXLINE(  65)					if ((limit < (int)16777216)) {
HXLINE(  65)						if ((limit < (int)524288)) {
HXLINE(  65)							n = ((int)15 + log2_4->__get(((int)limit >> (int)(int)15)));
            						}
            						else {
HXLINE(  65)							n = ((int)20 + log2_4->__get(((int)limit >> (int)(int)20)));
            						}
            					}
            					else {
HXLINE(  65)						if ((limit < (int)536870912)) {
HXLINE(  65)							n = ((int)25 + log2_4->__get(((int)limit >> (int)(int)25)));
            						}
            						else {
HXLINE(  65)							if ((limit < (int)-2147483648)) {
HXLINE(  65)								n = ((int)30 + log2_4->__get(((int)limit >> (int)(int)30)));
            							}
            							else {
HXLINE(  65)								n = (int)0;
            							}
            						}
            					}
            				}
HXDLIN(  65)				HX_VAR_NAME( int,n1,"n");
HXDLIN(  65)				if ((decodeState->validBits < (int)0)) {
HXLINE(  65)					n1 = (int)0;
            				}
            				else {
HXLINE(  65)					if ((decodeState->validBits < n)) {
HXLINE(  65)						if ((n > (int)24)) {
HXLINE(  65)							HX_VARI_NAME( int,n2,"n") = decodeState->readBits((int)24);
HXDLIN(  65)							n1 = (n2 + ((int)decodeState->readBits((n - (int)24)) << (int)(int)24));
            						}
            						else {
HXLINE(  65)							if ((decodeState->validBits == (int)0)) {
HXLINE(  65)								decodeState->acc = (int)0;
            							}
HXDLIN(  65)							while(true){
HXLINE(  65)								bool n3;
HXDLIN(  65)								if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  65)									if (!(decodeState->lastSeg)) {
HXLINE(  65)										n3 = (decodeState->next() == (int)0);
            									}
            									else {
HXLINE(  65)										n3 = true;
            									}
            								}
            								else {
HXLINE(  65)									n3 = false;
            								}
HXDLIN(  65)								if (n3) {
HXLINE(  65)									decodeState->validBits = (int)-1;
HXDLIN(  65)									goto _hx_goto_48;
            								}
            								else {
HXLINE(  65)									decodeState->bytesInSeg--;
HXDLIN(  65)									int a11 = decodeState->acc;
HXDLIN(  65)									decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  65)									int b11 = decodeState->input->readByte();
HXDLIN(  65)									decodeState->acc = (a11 + ((int)b11 << (int)decodeState->validBits));
HXDLIN(  65)									decodeState->validBits = (decodeState->validBits + (int)8);
            								}
HXDLIN(  65)								if (!((decodeState->validBits < n))) {
HXLINE(  65)									goto _hx_goto_48;
            								}
            							}
            							_hx_goto_48:;
HXDLIN(  65)							if ((decodeState->validBits < (int)0)) {
HXLINE(  65)								n1 = (int)0;
            							}
            							else {
HXLINE(  65)								HX_VARI_NAME( int,z22,"z") = ((int)decodeState->acc & (int)(((int)(int)1 << (int)n) - (int)1));
HXDLIN(  65)								decodeState->acc = hx::UShr(decodeState->acc,n);
HXDLIN(  65)								decodeState->validBits = (decodeState->validBits - n);
HXDLIN(  65)								n1 = z22;
            							}
            						}
            					}
            					else {
HXLINE(  65)						HX_VARI_NAME( int,z23,"z") = ((int)decodeState->acc & (int)(((int)(int)1 << (int)n) - (int)1));
HXDLIN(  65)						decodeState->acc = hx::UShr(decodeState->acc,n);
HXDLIN(  65)						decodeState->validBits = (decodeState->validBits - n);
HXDLIN(  65)						n1 = z23;
            					}
            				}
HXLINE(  66)				if (((currentEntry + n1) > c->entries)) {
HXLINE(  67)					HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("codebook entrys",cb,3a,30,82),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),67,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("read",56,4b,a7,4b))));
            				}
HXLINE(  69)				{
HXLINE(  69)					HX_VARI( int,_g1) = (int)0;
HXDLIN(  69)					HX_VARI( int,_g) = n1;
HXDLIN(  69)					while((_g1 < _g)){
HXLINE(  69)						_g1 = (_g1 + (int)1);
HXLINE(  70)						lengths->__unsafe_set((currentEntry + (_g1 - (int)1)),currentLength2);
            					}
            				}
HXLINE(  72)				currentEntry = (currentEntry + n1);
HXLINE(  73)				currentLength2 = (currentLength2 + (int)1);
            			}
            		}
            		else {
HXLINE(  76)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN(  76)			HX_VARI_NAME( int,_g2,"_g") = c->entries;
HXDLIN(  76)			while((_g11 < _g2)){
HXLINE(  76)				_g11 = (_g11 + (int)1);
HXDLIN(  76)				HX_VARI( int,j) = (_g11 - (int)1);
HXLINE(  77)				HX_VAR( int,present);
HXDLIN(  77)				if (c->sparse) {
HXLINE(  77)					if ((decodeState->validBits < (int)0)) {
HXLINE(  77)						present = (int)0;
            					}
            					else {
HXLINE(  77)						if ((decodeState->validBits < (int)1)) {
HXLINE(  77)							if ((decodeState->validBits == (int)0)) {
HXLINE(  77)								decodeState->acc = (int)0;
            							}
HXDLIN(  77)							while(true){
HXLINE(  77)								bool present1;
HXDLIN(  77)								if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  77)									if (!(decodeState->lastSeg)) {
HXLINE(  77)										present1 = (decodeState->next() == (int)0);
            									}
            									else {
HXLINE(  77)										present1 = true;
            									}
            								}
            								else {
HXLINE(  77)									present1 = false;
            								}
HXDLIN(  77)								if (present1) {
HXLINE(  77)									decodeState->validBits = (int)-1;
HXDLIN(  77)									goto _hx_goto_51;
            								}
            								else {
HXLINE(  77)									decodeState->bytesInSeg--;
HXDLIN(  77)									int a12 = decodeState->acc;
HXDLIN(  77)									decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  77)									int b12 = decodeState->input->readByte();
HXDLIN(  77)									decodeState->acc = (a12 + ((int)b12 << (int)decodeState->validBits));
HXDLIN(  77)									decodeState->validBits = (decodeState->validBits + (int)8);
            								}
HXDLIN(  77)								if (!((decodeState->validBits < (int)1))) {
HXLINE(  77)									goto _hx_goto_51;
            								}
            							}
            							_hx_goto_51:;
HXDLIN(  77)							if ((decodeState->validBits < (int)0)) {
HXLINE(  77)								present = (int)0;
            							}
            							else {
HXLINE(  77)								HX_VARI_NAME( int,z24,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  77)								decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  77)								decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  77)								present = z24;
            							}
            						}
            						else {
HXLINE(  77)							HX_VARI_NAME( int,z25,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  77)							decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  77)							decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  77)							present = z25;
            						}
            					}
            				}
            				else {
HXLINE(  77)					present = (int)1;
            				}
HXLINE(  78)				if ((present != (int)0)) {
HXLINE(  79)					{
HXLINE(  79)						int val;
HXDLIN(  79)						if ((decodeState->validBits < (int)0)) {
HXLINE(  79)							val = (int)0;
            						}
            						else {
HXLINE(  79)							if ((decodeState->validBits < (int)5)) {
HXLINE(  79)								if ((decodeState->validBits == (int)0)) {
HXLINE(  79)									decodeState->acc = (int)0;
            								}
HXDLIN(  79)								while(true){
HXLINE(  79)									bool val1;
HXDLIN(  79)									if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  79)										if (!(decodeState->lastSeg)) {
HXLINE(  79)											val1 = (decodeState->next() == (int)0);
            										}
            										else {
HXLINE(  79)											val1 = true;
            										}
            									}
            									else {
HXLINE(  79)										val1 = false;
            									}
HXDLIN(  79)									if (val1) {
HXLINE(  79)										decodeState->validBits = (int)-1;
HXDLIN(  79)										goto _hx_goto_52;
            									}
            									else {
HXLINE(  79)										decodeState->bytesInSeg--;
HXDLIN(  79)										int a13 = decodeState->acc;
HXDLIN(  79)										decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  79)										int b13 = decodeState->input->readByte();
HXDLIN(  79)										decodeState->acc = (a13 + ((int)b13 << (int)decodeState->validBits));
HXDLIN(  79)										decodeState->validBits = (decodeState->validBits + (int)8);
            									}
HXDLIN(  79)									if (!((decodeState->validBits < (int)5))) {
HXLINE(  79)										goto _hx_goto_52;
            									}
            								}
            								_hx_goto_52:;
HXDLIN(  79)								if ((decodeState->validBits < (int)0)) {
HXLINE(  79)									val = (int)0;
            								}
            								else {
HXLINE(  79)									HX_VARI_NAME( int,z26,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  79)									decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  79)									decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  79)									val = z26;
            								}
            							}
            							else {
HXLINE(  79)								HX_VARI_NAME( int,z27,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  79)								decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  79)								decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  79)								val = z27;
            							}
            						}
HXDLIN(  79)						lengths->__unsafe_set(j,(val + (int)1));
            					}
HXLINE(  80)					total = (total + (int)1);
            				}
            				else {
HXLINE(  82)					lengths->__unsafe_set(j,(int)255);
            				}
            			}
            		}
HXLINE(  87)		bool _hx_tmp15;
HXDLIN(  87)		if (c->sparse) {
HXLINE(  87)			_hx_tmp15 = (total >= ((int)c->entries >> (int)(int)2));
            		}
            		else {
HXLINE(  87)			_hx_tmp15 = false;
            		}
HXDLIN(  87)		if (_hx_tmp15) {
HXLINE(  88)			c->codewordLengths = lengths;
HXLINE(  89)			c->sparse = false;
            		}
HXLINE(  92)		int _hx_tmp16;
HXDLIN(  92)		if (c->sparse) {
HXLINE(  92)			_hx_tmp16 = total;
            		}
            		else {
HXLINE(  95)			HX_VARI( int,sortedCount) = (int)0;
HXLINE(  96)			{
HXLINE(  96)				HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN(  96)				HX_VARI_NAME( int,_g3,"_g") = c->entries;
HXDLIN(  96)				while((_g12 < _g3)){
HXLINE(  96)					_g12 = (_g12 + (int)1);
HXLINE(  97)					HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(lengths,(_g12 - (int)1))) );
HXLINE(  98)					bool _hx_tmp17;
HXDLIN(  98)					if ((l > (int)10)) {
HXLINE(  98)						_hx_tmp17 = (l != (int)255);
            					}
            					else {
HXLINE(  98)						_hx_tmp17 = false;
            					}
HXDLIN(  98)					if (_hx_tmp17) {
HXLINE(  99)						sortedCount = (sortedCount + (int)1);
            					}
            				}
            			}
HXLINE(  92)			_hx_tmp16 = sortedCount;
            		}
HXDLIN(  92)		c->sortedEntries = _hx_tmp16;
HXLINE( 105)		HX_VARI( ::Array< int >,values) = null();
HXLINE( 107)		if (!(c->sparse)) {
HXLINE( 108)			c->codewords = ::Array_obj< int >::__new(c->entries);
            		}
            		else {
HXLINE( 110)			if ((c->sortedEntries != (int)0)) {
HXLINE( 111)				c->codewordLengths = ::Array_obj< int >::__new(c->sortedEntries);
HXLINE( 112)				c->codewords = ::Array_obj< int >::__new(c->entries);
HXLINE( 113)				values = ::Array_obj< int >::__new(c->entries);
            			}
            		}
HXLINE( 119)		if (!(c->computeCodewords(lengths,c->entries,values))) {
HXLINE( 120)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("compute codewords",33,59,f7,f8),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),120,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("read",56,4b,a7,4b))));
            		}
HXLINE( 123)		if ((c->sortedEntries != (int)0)) {
HXLINE( 125)			c->sortedCodewords = ::Array_obj< int >::__new(0);
HXLINE( 129)			c->sortedValues = ::Array_obj< int >::__new(c->sortedEntries);
HXLINE( 130)			c->computeSortedHuffman(lengths,values);
            		}
HXLINE( 133)		if (c->sparse) {
HXLINE( 135)			c->codewords = null();
HXLINE( 136)			lengths = null();
            		}
HXLINE( 139)		c->computeAcceleratedHuffman();
HXLINE( 141)		int _hx_tmp18;
HXDLIN( 141)		if ((decodeState->validBits < (int)0)) {
HXLINE( 141)			_hx_tmp18 = (int)0;
            		}
            		else {
HXLINE( 141)			if ((decodeState->validBits < (int)4)) {
HXLINE( 141)				if ((decodeState->validBits == (int)0)) {
HXLINE( 141)					decodeState->acc = (int)0;
            				}
HXDLIN( 141)				while(true){
HXLINE( 141)					bool _hx_tmp19;
HXDLIN( 141)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 141)						if (!(decodeState->lastSeg)) {
HXLINE( 141)							_hx_tmp19 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 141)							_hx_tmp19 = true;
            						}
            					}
            					else {
HXLINE( 141)						_hx_tmp19 = false;
            					}
HXDLIN( 141)					if (_hx_tmp19) {
HXLINE( 141)						decodeState->validBits = (int)-1;
HXDLIN( 141)						goto _hx_goto_54;
            					}
            					else {
HXLINE( 141)						decodeState->bytesInSeg--;
HXDLIN( 141)						int a14 = decodeState->acc;
HXDLIN( 141)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 141)						int b14 = decodeState->input->readByte();
HXDLIN( 141)						decodeState->acc = (a14 + ((int)b14 << (int)decodeState->validBits));
HXDLIN( 141)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 141)					if (!((decodeState->validBits < (int)4))) {
HXLINE( 141)						goto _hx_goto_54;
            					}
            				}
            				_hx_goto_54:;
HXDLIN( 141)				if ((decodeState->validBits < (int)0)) {
HXLINE( 141)					_hx_tmp18 = (int)0;
            				}
            				else {
HXLINE( 141)					HX_VARI_NAME( int,z28,"z") = ((int)decodeState->acc & (int)(int)15);
HXDLIN( 141)					decodeState->acc = hx::UShr(decodeState->acc,(int)4);
HXDLIN( 141)					decodeState->validBits = (decodeState->validBits - (int)4);
HXDLIN( 141)					_hx_tmp18 = z28;
            				}
            			}
            			else {
HXLINE( 141)				HX_VARI_NAME( int,z29,"z") = ((int)decodeState->acc & (int)(int)15);
HXDLIN( 141)				decodeState->acc = hx::UShr(decodeState->acc,(int)4);
HXDLIN( 141)				decodeState->validBits = (decodeState->validBits - (int)4);
HXDLIN( 141)				_hx_tmp18 = z29;
            			}
            		}
HXDLIN( 141)		c->lookupType = _hx_tmp18;
HXLINE( 142)		if ((c->lookupType > (int)2)) {
HXLINE( 143)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("codebook lookup type",d6,92,ea,e4),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),143,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("read",56,4b,a7,4b))));
            		}
HXLINE( 146)		if ((c->lookupType > (int)0)) {
HXLINE( 147)			HX_VAR_NAME( int,x4,"x");
HXDLIN( 147)			if ((decodeState->validBits < (int)0)) {
HXLINE( 147)				x4 = (int)0;
            			}
            			else {
HXLINE( 147)				if ((decodeState->validBits < (int)32)) {
HXLINE( 147)					HX_VARI_NAME( int,x5,"x") = decodeState->readBits((int)24);
HXDLIN( 147)					x4 = (x5 + ((int)decodeState->readBits((int)8) << (int)(int)24));
            				}
            				else {
HXLINE( 147)					HX_VARI_NAME( int,z30,"z") = ((int)decodeState->acc & (int)(int)0);
HXDLIN( 147)					decodeState->acc = hx::UShr(decodeState->acc,(int)32);
HXDLIN( 147)					decodeState->validBits = (decodeState->validBits - (int)32);
HXDLIN( 147)					x4 = z30;
            				}
            			}
HXDLIN( 147)			HX_VAR( Float,mantissa);
HXDLIN( 147)			HX_VARI_NAME( int,_hx_int,"int") = ((int)x4 & (int)(int)2097151);
HXDLIN( 147)			if ((_hx_int < (int)0)) {
HXLINE( 147)				mantissa = (((Float)4294967296.0) + _hx_int);
            			}
            			else {
HXLINE( 147)				mantissa = (_hx_int + ((Float)0.0));
            			}
HXDLIN( 147)			HX_VAR( Float,res);
HXDLIN( 147)			if ((((int)x4 & (int)(int)-2147483648) != (int)0)) {
HXLINE( 147)				res = -(mantissa);
            			}
            			else {
HXLINE( 147)				res = mantissa;
            			}
HXDLIN( 147)			c->minimumValue = (res * ::Math_obj::pow((int)2,(hx::UShr(((int)x4 & (int)(int)2145386496),(int)21) - (int)788)));
HXLINE( 148)			HX_VAR_NAME( int,x6,"x");
HXDLIN( 148)			if ((decodeState->validBits < (int)0)) {
HXLINE( 148)				x6 = (int)0;
            			}
            			else {
HXLINE( 148)				if ((decodeState->validBits < (int)32)) {
HXLINE( 148)					HX_VARI_NAME( int,x7,"x") = decodeState->readBits((int)24);
HXDLIN( 148)					x6 = (x7 + ((int)decodeState->readBits((int)8) << (int)(int)24));
            				}
            				else {
HXLINE( 148)					HX_VARI_NAME( int,z31,"z") = ((int)decodeState->acc & (int)(int)0);
HXDLIN( 148)					decodeState->acc = hx::UShr(decodeState->acc,(int)32);
HXDLIN( 148)					decodeState->validBits = (decodeState->validBits - (int)32);
HXDLIN( 148)					x6 = z31;
            				}
            			}
HXDLIN( 148)			HX_VAR_NAME( Float,mantissa1,"mantissa");
HXDLIN( 148)			HX_VARI_NAME( int,int1,"int") = ((int)x6 & (int)(int)2097151);
HXDLIN( 148)			if ((int1 < (int)0)) {
HXLINE( 148)				mantissa1 = (((Float)4294967296.0) + int1);
            			}
            			else {
HXLINE( 148)				mantissa1 = (int1 + ((Float)0.0));
            			}
HXDLIN( 148)			HX_VAR_NAME( Float,res1,"res");
HXDLIN( 148)			if ((((int)x6 & (int)(int)-2147483648) != (int)0)) {
HXLINE( 148)				res1 = -(mantissa1);
            			}
            			else {
HXLINE( 148)				res1 = mantissa1;
            			}
HXDLIN( 148)			c->deltaValue = (res1 * ::Math_obj::pow((int)2,(hx::UShr(((int)x6 & (int)(int)2145386496),(int)21) - (int)788)));
HXLINE( 149)			int _hx_tmp20;
HXDLIN( 149)			if ((decodeState->validBits < (int)0)) {
HXLINE( 149)				_hx_tmp20 = (int)0;
            			}
            			else {
HXLINE( 149)				if ((decodeState->validBits < (int)4)) {
HXLINE( 149)					if ((decodeState->validBits == (int)0)) {
HXLINE( 149)						decodeState->acc = (int)0;
            					}
HXDLIN( 149)					while(true){
HXLINE( 149)						bool _hx_tmp21;
HXDLIN( 149)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 149)							if (!(decodeState->lastSeg)) {
HXLINE( 149)								_hx_tmp21 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE( 149)								_hx_tmp21 = true;
            							}
            						}
            						else {
HXLINE( 149)							_hx_tmp21 = false;
            						}
HXDLIN( 149)						if (_hx_tmp21) {
HXLINE( 149)							decodeState->validBits = (int)-1;
HXDLIN( 149)							goto _hx_goto_55;
            						}
            						else {
HXLINE( 149)							decodeState->bytesInSeg--;
HXDLIN( 149)							int a15 = decodeState->acc;
HXDLIN( 149)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 149)							int b15 = decodeState->input->readByte();
HXDLIN( 149)							decodeState->acc = (a15 + ((int)b15 << (int)decodeState->validBits));
HXDLIN( 149)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN( 149)						if (!((decodeState->validBits < (int)4))) {
HXLINE( 149)							goto _hx_goto_55;
            						}
            					}
            					_hx_goto_55:;
HXDLIN( 149)					if ((decodeState->validBits < (int)0)) {
HXLINE( 149)						_hx_tmp20 = (int)0;
            					}
            					else {
HXLINE( 149)						HX_VARI_NAME( int,z32,"z") = ((int)decodeState->acc & (int)(int)15);
HXDLIN( 149)						decodeState->acc = hx::UShr(decodeState->acc,(int)4);
HXDLIN( 149)						decodeState->validBits = (decodeState->validBits - (int)4);
HXDLIN( 149)						_hx_tmp20 = z32;
            					}
            				}
            				else {
HXLINE( 149)					HX_VARI_NAME( int,z33,"z") = ((int)decodeState->acc & (int)(int)15);
HXDLIN( 149)					decodeState->acc = hx::UShr(decodeState->acc,(int)4);
HXDLIN( 149)					decodeState->validBits = (decodeState->validBits - (int)4);
HXDLIN( 149)					_hx_tmp20 = z33;
            				}
            			}
HXDLIN( 149)			c->valueBits = (_hx_tmp20 + (int)1);
HXLINE( 150)			int _hx_tmp22;
HXDLIN( 150)			if ((decodeState->validBits < (int)0)) {
HXLINE( 150)				_hx_tmp22 = (int)0;
            			}
            			else {
HXLINE( 150)				if ((decodeState->validBits < (int)1)) {
HXLINE( 150)					if ((decodeState->validBits == (int)0)) {
HXLINE( 150)						decodeState->acc = (int)0;
            					}
HXDLIN( 150)					while(true){
HXLINE( 150)						bool _hx_tmp23;
HXDLIN( 150)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 150)							if (!(decodeState->lastSeg)) {
HXLINE( 150)								_hx_tmp23 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE( 150)								_hx_tmp23 = true;
            							}
            						}
            						else {
HXLINE( 150)							_hx_tmp23 = false;
            						}
HXDLIN( 150)						if (_hx_tmp23) {
HXLINE( 150)							decodeState->validBits = (int)-1;
HXDLIN( 150)							goto _hx_goto_56;
            						}
            						else {
HXLINE( 150)							decodeState->bytesInSeg--;
HXDLIN( 150)							int a16 = decodeState->acc;
HXDLIN( 150)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 150)							int b16 = decodeState->input->readByte();
HXDLIN( 150)							decodeState->acc = (a16 + ((int)b16 << (int)decodeState->validBits));
HXDLIN( 150)							decodeState->validBits = (decodeState->validBits + (int)8);
            						}
HXDLIN( 150)						if (!((decodeState->validBits < (int)1))) {
HXLINE( 150)							goto _hx_goto_56;
            						}
            					}
            					_hx_goto_56:;
HXDLIN( 150)					if ((decodeState->validBits < (int)0)) {
HXLINE( 150)						_hx_tmp22 = (int)0;
            					}
            					else {
HXLINE( 150)						HX_VARI_NAME( int,z34,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN( 150)						decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN( 150)						decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN( 150)						_hx_tmp22 = z34;
            					}
            				}
            				else {
HXLINE( 150)					HX_VARI_NAME( int,z35,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN( 150)					decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN( 150)					decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN( 150)					_hx_tmp22 = z35;
            				}
            			}
HXDLIN( 150)			c->sequenceP = (_hx_tmp22 != (int)0);
HXLINE( 152)			if ((c->lookupType == (int)1)) {
HXLINE( 153)				c->lookupValues = ::stb::format::vorbis::VorbisTools_obj::lookup1Values(c->entries,c->dimensions);
            			}
            			else {
HXLINE( 155)				c->lookupValues = (c->entries * c->dimensions);
            			}
HXLINE( 157)			HX_VARI( ::Array< int >,mults) = ::Array_obj< int >::__new(c->lookupValues);
HXLINE( 158)			{
HXLINE( 158)				HX_VARI_NAME( int,_g13,"_g1") = (int)0;
HXDLIN( 158)				HX_VARI_NAME( int,_g4,"_g") = c->lookupValues;
HXDLIN( 158)				while((_g13 < _g4)){
HXLINE( 158)					_g13 = (_g13 + (int)1);
HXDLIN( 158)					HX_VARI_NAME( int,j1,"j") = (_g13 - (int)1);
HXLINE( 159)					HX_VARI_NAME( int,n4,"n") = c->valueBits;
HXDLIN( 159)					HX_VAR( int,q);
HXDLIN( 159)					if ((decodeState->validBits < (int)0)) {
HXLINE( 159)						q = (int)0;
            					}
            					else {
HXLINE( 159)						if ((decodeState->validBits < n4)) {
HXLINE( 159)							if ((n4 > (int)24)) {
HXLINE( 159)								HX_VARI_NAME( int,q1,"q") = decodeState->readBits((int)24);
HXDLIN( 159)								q = (q1 + ((int)decodeState->readBits((n4 - (int)24)) << (int)(int)24));
            							}
            							else {
HXLINE( 159)								if ((decodeState->validBits == (int)0)) {
HXLINE( 159)									decodeState->acc = (int)0;
            								}
HXDLIN( 159)								while(true){
HXLINE( 159)									bool q2;
HXDLIN( 159)									if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 159)										if (!(decodeState->lastSeg)) {
HXLINE( 159)											q2 = (decodeState->next() == (int)0);
            										}
            										else {
HXLINE( 159)											q2 = true;
            										}
            									}
            									else {
HXLINE( 159)										q2 = false;
            									}
HXDLIN( 159)									if (q2) {
HXLINE( 159)										decodeState->validBits = (int)-1;
HXDLIN( 159)										goto _hx_goto_58;
            									}
            									else {
HXLINE( 159)										decodeState->bytesInSeg--;
HXDLIN( 159)										int a17 = decodeState->acc;
HXDLIN( 159)										decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 159)										int b17 = decodeState->input->readByte();
HXDLIN( 159)										decodeState->acc = (a17 + ((int)b17 << (int)decodeState->validBits));
HXDLIN( 159)										decodeState->validBits = (decodeState->validBits + (int)8);
            									}
HXDLIN( 159)									if (!((decodeState->validBits < n4))) {
HXLINE( 159)										goto _hx_goto_58;
            									}
            								}
            								_hx_goto_58:;
HXDLIN( 159)								if ((decodeState->validBits < (int)0)) {
HXLINE( 159)									q = (int)0;
            								}
            								else {
HXLINE( 159)									HX_VARI_NAME( int,z36,"z") = ((int)decodeState->acc & (int)(((int)(int)1 << (int)n4) - (int)1));
HXDLIN( 159)									decodeState->acc = hx::UShr(decodeState->acc,n4);
HXDLIN( 159)									decodeState->validBits = (decodeState->validBits - n4);
HXDLIN( 159)									q = z36;
            								}
            							}
            						}
            						else {
HXLINE( 159)							HX_VARI_NAME( int,z37,"z") = ((int)decodeState->acc & (int)(((int)(int)1 << (int)n4) - (int)1));
HXDLIN( 159)							decodeState->acc = hx::UShr(decodeState->acc,n4);
HXDLIN( 159)							decodeState->validBits = (decodeState->validBits - n4);
HXDLIN( 159)							q = z37;
            						}
            					}
HXLINE( 160)					if ((q == (int)-1)) {
HXLINE( 161)						HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("fail lookup",7c,d8,86,6f),hx::SourceInfo(HX_("Codebook.hx",88,14,e0,8e),161,HX_("stb.format.vorbis.data.Codebook",a9,9d,45,19),HX_("read",56,4b,a7,4b))));
            					}
HXLINE( 163)					mults->__unsafe_set(j1,q);
            				}
            			}
HXLINE( 166)			{
HXLINE( 167)				c->multiplicands = ::Array_obj< Float >::__new(c->lookupValues);
HXLINE( 170)				{
HXLINE( 170)					HX_VARI_NAME( int,_g14,"_g1") = (int)0;
HXDLIN( 170)					HX_VARI_NAME( int,_g5,"_g") = c->lookupValues;
HXDLIN( 170)					while((_g14 < _g5)){
HXLINE( 170)						_g14 = (_g14 + (int)1);
HXDLIN( 170)						HX_VARI_NAME( int,j2,"j") = (_g14 - (int)1);
HXLINE( 171)						{
HXLINE( 171)							::Array< Float > this1 = c->multiplicands;
HXDLIN( 171)							Float val2 = (( (int)(_hx_array_unsafe_get(mults,j2)) ) * c->deltaValue);
HXDLIN( 171)							this1->__unsafe_set(j2,(val2 + c->minimumValue));
            						}
            					}
            				}
            			}
HXLINE( 176)			bool _hx_tmp24;
HXDLIN( 176)			if ((c->lookupType == (int)2)) {
HXLINE( 176)				_hx_tmp24 = c->sequenceP;
            			}
            			else {
HXLINE( 176)				_hx_tmp24 = false;
            			}
HXDLIN( 176)			if (_hx_tmp24) {
HXLINE( 177)				{
HXLINE( 177)					HX_VARI_NAME( int,_g15,"_g1") = (int)1;
HXDLIN( 177)					HX_VARI_NAME( int,_g6,"_g") = c->lookupValues;
HXDLIN( 177)					while((_g15 < _g6)){
HXLINE( 177)						_g15 = (_g15 + (int)1);
HXDLIN( 177)						HX_VARI_NAME( int,j3,"j") = (_g15 - (int)1);
HXLINE( 178)						{
HXLINE( 178)							::Array< Float > this2 = c->multiplicands;
HXDLIN( 178)							Float val3 = ( (Float)(_hx_array_unsafe_get(c->multiplicands,(j3 - (int)1))) );
HXDLIN( 178)							this2->__unsafe_set(j3,val3);
            						}
            					}
            				}
HXLINE( 180)				c->sequenceP = false;
            			}
            		}
HXLINE( 184)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,read,return )

int Codebook_obj::delay;


hx::ObjectPtr< Codebook_obj > Codebook_obj::__new() {
	hx::ObjectPtr< Codebook_obj > __this = new Codebook_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Codebook_obj > Codebook_obj::__alloc(hx::Ctx *_hx_ctx) {
	Codebook_obj *__this = (Codebook_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Codebook_obj), true, "stb.format.vorbis.data.Codebook"));
	*(void **)__this = Codebook_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Codebook_obj::Codebook_obj()
{
}

void Codebook_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Codebook);
	HX_MARK_MEMBER_NAME(dimensions,"dimensions");
	HX_MARK_MEMBER_NAME(entries,"entries");
	HX_MARK_MEMBER_NAME(codewordLengths,"codewordLengths");
	HX_MARK_MEMBER_NAME(minimumValue,"minimumValue");
	HX_MARK_MEMBER_NAME(deltaValue,"deltaValue");
	HX_MARK_MEMBER_NAME(valueBits,"valueBits");
	HX_MARK_MEMBER_NAME(lookupType,"lookupType");
	HX_MARK_MEMBER_NAME(sequenceP,"sequenceP");
	HX_MARK_MEMBER_NAME(sparse,"sparse");
	HX_MARK_MEMBER_NAME(lookupValues,"lookupValues");
	HX_MARK_MEMBER_NAME(multiplicands,"multiplicands");
	HX_MARK_MEMBER_NAME(codewords,"codewords");
	HX_MARK_MEMBER_NAME(fastHuffman,"fastHuffman");
	HX_MARK_MEMBER_NAME(sortedCodewords,"sortedCodewords");
	HX_MARK_MEMBER_NAME(sortedValues,"sortedValues");
	HX_MARK_MEMBER_NAME(sortedEntries,"sortedEntries");
	HX_MARK_END_CLASS();
}

void Codebook_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(dimensions,"dimensions");
	HX_VISIT_MEMBER_NAME(entries,"entries");
	HX_VISIT_MEMBER_NAME(codewordLengths,"codewordLengths");
	HX_VISIT_MEMBER_NAME(minimumValue,"minimumValue");
	HX_VISIT_MEMBER_NAME(deltaValue,"deltaValue");
	HX_VISIT_MEMBER_NAME(valueBits,"valueBits");
	HX_VISIT_MEMBER_NAME(lookupType,"lookupType");
	HX_VISIT_MEMBER_NAME(sequenceP,"sequenceP");
	HX_VISIT_MEMBER_NAME(sparse,"sparse");
	HX_VISIT_MEMBER_NAME(lookupValues,"lookupValues");
	HX_VISIT_MEMBER_NAME(multiplicands,"multiplicands");
	HX_VISIT_MEMBER_NAME(codewords,"codewords");
	HX_VISIT_MEMBER_NAME(fastHuffman,"fastHuffman");
	HX_VISIT_MEMBER_NAME(sortedCodewords,"sortedCodewords");
	HX_VISIT_MEMBER_NAME(sortedValues,"sortedValues");
	HX_VISIT_MEMBER_NAME(sortedEntries,"sortedEntries");
}

hx::Val Codebook_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sparse") ) { return hx::Val( sparse); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"entries") ) { return hx::Val( entries); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addEntry") ) { return hx::Val( addEntry_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"valueBits") ) { return hx::Val( valueBits); }
		if (HX_FIELD_EQ(inName,"sequenceP") ) { return hx::Val( sequenceP); }
		if (HX_FIELD_EQ(inName,"codewords") ) { return hx::Val( codewords); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dimensions") ) { return hx::Val( dimensions); }
		if (HX_FIELD_EQ(inName,"deltaValue") ) { return hx::Val( deltaValue); }
		if (HX_FIELD_EQ(inName,"lookupType") ) { return hx::Val( lookupType); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"fastHuffman") ) { return hx::Val( fastHuffman); }
		if (HX_FIELD_EQ(inName,"decodeStart") ) { return hx::Val( decodeStart_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"minimumValue") ) { return hx::Val( minimumValue); }
		if (HX_FIELD_EQ(inName,"lookupValues") ) { return hx::Val( lookupValues); }
		if (HX_FIELD_EQ(inName,"sortedValues") ) { return hx::Val( sortedValues); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"multiplicands") ) { return hx::Val( multiplicands); }
		if (HX_FIELD_EQ(inName,"sortedEntries") ) { return hx::Val( sortedEntries); }
		if (HX_FIELD_EQ(inName,"includeInSort") ) { return hx::Val( includeInSort_dyn()); }
		if (HX_FIELD_EQ(inName,"residueDecode") ) { return hx::Val( residueDecode_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"codebookDecode") ) { return hx::Val( codebookDecode_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"codewordLengths") ) { return hx::Val( codewordLengths); }
		if (HX_FIELD_EQ(inName,"sortedCodewords") ) { return hx::Val( sortedCodewords); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"computeCodewords") ) { return hx::Val( computeCodewords_dyn()); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"codebookDecodeStep") ) { return hx::Val( codebookDecodeStep_dyn()); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"computeSortedHuffman") ) { return hx::Val( computeSortedHuffman_dyn()); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"decodeDeinterleaveRepeat") ) { return hx::Val( decodeDeinterleaveRepeat_dyn()); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"computeAcceleratedHuffman") ) { return hx::Val( computeAcceleratedHuffman_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

bool Codebook_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { outValue = delay; return true; }
	}
	return false;
}

hx::Val Codebook_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sparse") ) { sparse=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"entries") ) { entries=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"valueBits") ) { valueBits=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sequenceP") ) { sequenceP=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"codewords") ) { codewords=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dimensions") ) { dimensions=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"deltaValue") ) { deltaValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lookupType") ) { lookupType=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"fastHuffman") ) { fastHuffman=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"minimumValue") ) { minimumValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lookupValues") ) { lookupValues=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedValues") ) { sortedValues=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"multiplicands") ) { multiplicands=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedEntries") ) { sortedEntries=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"codewordLengths") ) { codewordLengths=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedCodewords") ) { sortedCodewords=inValue.Cast< ::Array< int > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Codebook_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { delay=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Codebook_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("dimensions","\x4d","\xbe","\x9f","\xdc"));
	outFields->push(HX_HCSTRING("entries","\x50","\x2d","\x5f","\x79"));
	outFields->push(HX_HCSTRING("codewordLengths","\x16","\x3c","\xfc","\x19"));
	outFields->push(HX_HCSTRING("minimumValue","\xc3","\x5e","\x55","\xb4"));
	outFields->push(HX_HCSTRING("deltaValue","\x59","\x24","\xdb","\xdc"));
	outFields->push(HX_HCSTRING("valueBits","\x17","\xb3","\x9b","\x8d"));
	outFields->push(HX_HCSTRING("lookupType","\x54","\x86","\xf3","\x40"));
	outFields->push(HX_HCSTRING("sequenceP","\xef","\x5a","\x8d","\xe6"));
	outFields->push(HX_HCSTRING("sparse","\xe0","\x0e","\x60","\xb8"));
	outFields->push(HX_HCSTRING("lookupValues","\xfc","\x31","\x21","\x02"));
	outFields->push(HX_HCSTRING("multiplicands","\x0b","\x05","\xc0","\x91"));
	outFields->push(HX_HCSTRING("codewords","\x1c","\x7b","\x0d","\xcf"));
	outFields->push(HX_HCSTRING("fastHuffman","\xf1","\x9f","\x8c","\x5a"));
	outFields->push(HX_HCSTRING("sortedCodewords","\x1f","\xf8","\x5c","\x96"));
	outFields->push(HX_HCSTRING("sortedValues","\xff","\x96","\x90","\xf3"));
	outFields->push(HX_HCSTRING("sortedEntries","\x93","\x53","\xe6","\x33"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Codebook_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Codebook_obj,dimensions),HX_HCSTRING("dimensions","\x4d","\xbe","\x9f","\xdc")},
	{hx::fsInt,(int)offsetof(Codebook_obj,entries),HX_HCSTRING("entries","\x50","\x2d","\x5f","\x79")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Codebook_obj,codewordLengths),HX_HCSTRING("codewordLengths","\x16","\x3c","\xfc","\x19")},
	{hx::fsFloat,(int)offsetof(Codebook_obj,minimumValue),HX_HCSTRING("minimumValue","\xc3","\x5e","\x55","\xb4")},
	{hx::fsFloat,(int)offsetof(Codebook_obj,deltaValue),HX_HCSTRING("deltaValue","\x59","\x24","\xdb","\xdc")},
	{hx::fsInt,(int)offsetof(Codebook_obj,valueBits),HX_HCSTRING("valueBits","\x17","\xb3","\x9b","\x8d")},
	{hx::fsInt,(int)offsetof(Codebook_obj,lookupType),HX_HCSTRING("lookupType","\x54","\x86","\xf3","\x40")},
	{hx::fsBool,(int)offsetof(Codebook_obj,sequenceP),HX_HCSTRING("sequenceP","\xef","\x5a","\x8d","\xe6")},
	{hx::fsBool,(int)offsetof(Codebook_obj,sparse),HX_HCSTRING("sparse","\xe0","\x0e","\x60","\xb8")},
	{hx::fsInt,(int)offsetof(Codebook_obj,lookupValues),HX_HCSTRING("lookupValues","\xfc","\x31","\x21","\x02")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(Codebook_obj,multiplicands),HX_HCSTRING("multiplicands","\x0b","\x05","\xc0","\x91")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Codebook_obj,codewords),HX_HCSTRING("codewords","\x1c","\x7b","\x0d","\xcf")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Codebook_obj,fastHuffman),HX_HCSTRING("fastHuffman","\xf1","\x9f","\x8c","\x5a")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Codebook_obj,sortedCodewords),HX_HCSTRING("sortedCodewords","\x1f","\xf8","\x5c","\x96")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Codebook_obj,sortedValues),HX_HCSTRING("sortedValues","\xff","\x96","\x90","\xf3")},
	{hx::fsInt,(int)offsetof(Codebook_obj,sortedEntries),HX_HCSTRING("sortedEntries","\x93","\x53","\xe6","\x33")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Codebook_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Codebook_obj::NO_CODE,HX_HCSTRING("NO_CODE","\x2b","\x45","\x52","\x21")},
	{hx::fsInt,(void *) &Codebook_obj::delay,HX_HCSTRING("delay","\x83","\xd7","\x26","\xd7")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Codebook_obj_sMemberFields[] = {
	HX_HCSTRING("dimensions","\x4d","\xbe","\x9f","\xdc"),
	HX_HCSTRING("entries","\x50","\x2d","\x5f","\x79"),
	HX_HCSTRING("codewordLengths","\x16","\x3c","\xfc","\x19"),
	HX_HCSTRING("minimumValue","\xc3","\x5e","\x55","\xb4"),
	HX_HCSTRING("deltaValue","\x59","\x24","\xdb","\xdc"),
	HX_HCSTRING("valueBits","\x17","\xb3","\x9b","\x8d"),
	HX_HCSTRING("lookupType","\x54","\x86","\xf3","\x40"),
	HX_HCSTRING("sequenceP","\xef","\x5a","\x8d","\xe6"),
	HX_HCSTRING("sparse","\xe0","\x0e","\x60","\xb8"),
	HX_HCSTRING("lookupValues","\xfc","\x31","\x21","\x02"),
	HX_HCSTRING("multiplicands","\x0b","\x05","\xc0","\x91"),
	HX_HCSTRING("codewords","\x1c","\x7b","\x0d","\xcf"),
	HX_HCSTRING("fastHuffman","\xf1","\x9f","\x8c","\x5a"),
	HX_HCSTRING("sortedCodewords","\x1f","\xf8","\x5c","\x96"),
	HX_HCSTRING("sortedValues","\xff","\x96","\x90","\xf3"),
	HX_HCSTRING("sortedEntries","\x93","\x53","\xe6","\x33"),
	HX_HCSTRING("addEntry","\x91","\x9e","\xe3","\xe9"),
	HX_HCSTRING("includeInSort","\x2b","\x86","\xf6","\xb6"),
	HX_HCSTRING("computeCodewords","\xa5","\xec","\x44","\xc8"),
	HX_HCSTRING("computeSortedHuffman","\x79","\xff","\xc7","\xef"),
	HX_HCSTRING("computeAcceleratedHuffman","\x5d","\x4a","\x6a","\xc6"),
	HX_HCSTRING("codebookDecode","\xa4","\x25","\x0d","\xe9"),
	HX_HCSTRING("codebookDecodeStep","\x10","\xdb","\xef","\x6b"),
	HX_HCSTRING("decodeStart","\x54","\x00","\x25","\x4c"),
	HX_HCSTRING("decodeDeinterleaveRepeat","\x65","\x00","\x32","\x3c"),
	HX_HCSTRING("residueDecode","\xd9","\x53","\x88","\x4e"),
	::String(null()) };

static void Codebook_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Codebook_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Codebook_obj::NO_CODE,"NO_CODE");
	HX_MARK_MEMBER_NAME(Codebook_obj::delay,"delay");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Codebook_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Codebook_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Codebook_obj::NO_CODE,"NO_CODE");
	HX_VISIT_MEMBER_NAME(Codebook_obj::delay,"delay");
};

#endif

hx::Class Codebook_obj::__mClass;

static ::String Codebook_obj_sStaticFields[] = {
	HX_HCSTRING("NO_CODE","\x2b","\x45","\x52","\x21"),
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	HX_HCSTRING("delay","\x83","\xd7","\x26","\xd7"),
	::String(null())
};

void Codebook_obj::__register()
{
	hx::Object *dummy = new Codebook_obj;
	Codebook_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("stb.format.vorbis.data.Codebook","\xa9","\x9d","\x45","\x19");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Codebook_obj::__GetStatic;
	__mClass->mSetStaticField = &Codebook_obj::__SetStatic;
	__mClass->mMarkFunc = Codebook_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Codebook_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Codebook_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Codebook_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Codebook_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Codebook_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Codebook_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Codebook_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_15_boot)
HXLINE(  15)		NO_CODE = (int)255;
            	}
{
            	HX_STACKFRAME(&_hx_pos_8f92f7adc9e5843d_480_boot)
HXLINE( 480)		delay = (int)0;
            	}
}

} // end namespace stb
} // end namespace format
} // end namespace vorbis
} // end namespace data
