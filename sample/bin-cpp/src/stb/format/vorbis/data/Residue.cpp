// Generated by Haxe 3.4.0 (git build development @ 75c0f05)
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_VorbisDecodeState
#include <stb/format/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Codebook
#include <stb/format/vorbis/data/Codebook.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Header
#include <stb/format/vorbis/data/Header.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderError
#include <stb/format/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderErrorType
#include <stb/format/vorbis/data/ReaderErrorType.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Residue
#include <stb/format/vorbis/data/Residue.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b00c91391853c156_21_new,"stb.format.vorbis.data.Residue","new",0x906d32ca,"stb.format.vorbis.data.Residue.new","stb/format/vorbis/data/Residue.hx",21,0x88345266)
HX_DEFINE_STACK_FRAME(_hx_pos_b00c91391853c156_84_decode,"stb.format.vorbis.data.Residue","decode",0x376dd904,"stb.format.vorbis.data.Residue.decode","stb/format/vorbis/data/Residue.hx",84,0x88345266)
HX_DEFINE_STACK_FRAME(_hx_pos_b00c91391853c156_25_read,"stb.format.vorbis.data.Residue","read",0xd1c405ac,"stb.format.vorbis.data.Residue.read","stb/format/vorbis/data/Residue.hx",25,0x88345266)
namespace stb{
namespace format{
namespace vorbis{
namespace data{

void Residue_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_b00c91391853c156_21_new)
            	HX_STACK_THIS(this)
            	}

Dynamic Residue_obj::__CreateEmpty() { return new Residue_obj; }

void *Residue_obj::_hx_vtable = 0;

Dynamic Residue_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Residue_obj > _hx_result = new Residue_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Residue_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x74c8a5f6;
}

void Residue_obj::decode( ::stb::format::vorbis::VorbisDecodeState decodeState, ::stb::format::vorbis::data::Header header,::Array< ::Dynamic> residueBuffers,int ch,int n,::Array< bool > doNotDecode,::Array< ::Dynamic> channelBuffers){
            	HX_STACKFRAME(&_hx_pos_b00c91391853c156_84_decode)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(header,"header")
            	HX_STACK_ARG(residueBuffers,"residueBuffers")
            	HX_STACK_ARG(ch,"ch")
            	HX_STACK_ARG(n,"n")
            	HX_STACK_ARG(doNotDecode,"doNotDecode")
            	HX_STACK_ARG(channelBuffers,"channelBuffers")
HXLINE(  86)		HX_VARI( ::Array< ::Dynamic>,codebooks) = header->codebooks;
HXLINE(  87)		HX_VARI( int,classwords) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,this->classbook)) )->dimensions;
HXLINE(  89)		HX_VARI( int,partSize) = this->partSize;
HXLINE(  90)		HX_VARI_NAME( int,_hx_int,"int") = (this->end - this->begin);
HXDLIN(  90)		Float partRead;
HXDLIN(  90)		if ((_hx_int < (int)0)) {
HXLINE(  90)			partRead = (((Float)4294967296.0) + _hx_int);
            		}
            		else {
HXLINE(  90)			partRead = (_hx_int + ((Float)0.0));
            		}
HXDLIN(  90)		HX_VARI_NAME( int,int1,"int") = partSize;
HXDLIN(  90)		Float partRead1;
HXDLIN(  90)		if ((int1 < (int)0)) {
HXLINE(  90)			partRead1 = (((Float)4294967296.0) + int1);
            		}
            		else {
HXLINE(  90)			partRead1 = (int1 + ((Float)0.0));
            		}
HXDLIN(  90)		HX_VARI_NAME( int,partRead2,"partRead") = ::Std_obj::_hx_int(((Float)partRead / (Float)partRead1));
HXLINE(  91)		HX_VARI( ::Array< ::Dynamic>,partClassdata) = ::Array_obj< ::Dynamic>::__new((header->channel * partRead2));
HXLINE(  94)		{
HXLINE(  94)			HX_VARI( int,_g1) = (int)0;
HXDLIN(  94)			while((_g1 < ch)){
HXLINE(  94)				_g1 = (_g1 + (int)1);
HXDLIN(  94)				HX_VARI( int,i) = (_g1 - (int)1);
HXLINE(  95)				if (!(( (bool)(_hx_array_unsafe_get(doNotDecode,i)) ))) {
HXLINE(  96)					HX_VARI( ::Array< Float >,buffer) = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,i)) );
HXLINE(  97)					{
HXLINE(  97)						HX_VARI( int,_g3) = (int)0;
HXDLIN(  97)						HX_VARI( int,_g2) = buffer->length;
HXDLIN(  97)						while((_g3 < _g2)){
HXLINE(  97)							_g3 = (_g3 + (int)1);
HXLINE(  98)							buffer->__unsafe_set((_g3 - (int)1),(int)0);
            						}
            					}
            				}
            			}
            		}
HXLINE( 103)		bool _hx_tmp;
HXDLIN( 103)		if ((this->type == (int)2)) {
HXLINE( 103)			_hx_tmp = (ch != (int)1);
            		}
            		else {
HXLINE( 103)			_hx_tmp = false;
            		}
HXDLIN( 103)		if (_hx_tmp) {
HXLINE( 104)			{
HXLINE( 104)				HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 104)				while((_g11 < ch)){
HXLINE( 104)					_g11 = (_g11 + (int)1);
HXDLIN( 104)					HX_VARI( int,j) = (_g11 - (int)1);
HXLINE( 105)					if (!(( (bool)(_hx_array_unsafe_get(doNotDecode,j)) ))) {
HXLINE( 106)						goto _hx_goto_3;
            					}
            					else {
HXLINE( 107)						if ((j == (ch - (int)1))) {
HXLINE( 108)							return;
            						}
            					}
            				}
            				_hx_goto_3:;
            			}
HXLINE( 113)			{
HXLINE( 113)				HX_VARI( int,_g) = (int)0;
HXDLIN( 113)				while((_g < (int)8)){
HXLINE( 113)					_g = (_g + (int)1);
HXDLIN( 113)					HX_VARI( int,pass) = (_g - (int)1);
HXLINE( 114)					HX_VARI( int,pcount) = (int)0;
HXDLIN( 114)					HX_VARI( int,classSet) = (int)0;
HXLINE( 115)					if ((ch == (int)2)) {
HXLINE( 117)						while((pcount < partRead2)){
HXLINE( 118)							HX_VARI( int,z) = (this->begin + (pcount * partSize));
HXLINE( 119)							HX_VARI( int,cInter) = ((int)z & (int)(int)1);
HXLINE( 120)							HX_VARI( int,pInter) = hx::UShr(z,(int)1);
HXLINE( 121)							if ((pass == (int)0)) {
HXLINE( 122)								HX_VARI(  ::stb::format::vorbis::data::Codebook,c) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,this->classbook)) );
HXLINE( 123)								if ((decodeState->validBits < (int)10)) {
HXLINE( 123)									decodeState->prepHuffman();
            								}
HXDLIN( 123)								HX_VARI_NAME( int,i1,"i") = ( (int)(_hx_array_unsafe_get(c->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 123)								HX_VAR( int,val);
HXDLIN( 123)								if ((i1 >= (int)0)) {
HXLINE( 123)									HX_VARI( int,l) = ( (int)(_hx_array_unsafe_get(c->codewordLengths,i1)) );
HXDLIN( 123)									decodeState->acc = hx::UShr(decodeState->acc,l);
HXDLIN( 123)									decodeState->validBits = (decodeState->validBits - l);
HXDLIN( 123)									if ((decodeState->validBits < (int)0)) {
HXLINE( 123)										decodeState->validBits = (int)0;
HXDLIN( 123)										val = (int)-1;
            									}
            									else {
HXLINE( 123)										val = i1;
            									}
            								}
            								else {
HXLINE( 123)									val = decodeState->decodeScalarRaw(c);
            								}
HXDLIN( 123)								if (c->sparse) {
HXLINE( 123)									val = ( (int)(_hx_array_unsafe_get(c->sortedValues,val)) );
            								}
HXDLIN( 123)								HX_VARI( int,q) = val;
HXLINE( 124)								if ((q == (int)-1)) {
HXLINE( 125)									return;
            								}
HXLINE( 127)								{
HXLINE( 127)									::Array< int > val1 = ( (::Array< int >)(_hx_array_unsafe_get(this->classdata,q)) );
HXDLIN( 127)									partClassdata->__unsafe_set(classSet,val1);
            								}
            							}
HXLINE( 130)							{
HXLINE( 130)								HX_VARI_NAME( int,_g21,"_g2") = (int)0;
HXDLIN( 130)								while((_g21 < classwords)){
HXLINE( 130)									_g21 = (_g21 + (int)1);
HXLINE( 131)									if ((pcount >= partRead2)) {
HXLINE( 132)										goto _hx_goto_6;
            									}
HXLINE( 134)									HX_VARI_NAME( int,z1,"z") = (this->begin + (pcount * partSize));
HXLINE( 135)									HX_VARI_NAME( int,c1,"c") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(partClassdata,classSet)) ),(_g21 - (int)1))) );
HXLINE( 136)									HX_VARI( int,b) = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(this->residueBooks,c1)) ),pass)) );
HXLINE( 137)									if ((b >= (int)0)) {
HXLINE( 140)										HX_VARI(  ::Dynamic,result) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,b)) )->decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
HXLINE( 141)										if (hx::IsNull( result )) {
HXLINE( 142)											return;
            										}
            										else {
HXLINE( 144)											cInter = ( (int)(result->__Field(HX_("cInter",b9,e7,a2,e6),hx::paccDynamic)) );
HXLINE( 145)											pInter = ( (int)(result->__Field(HX_("pInter",8c,98,46,19),hx::paccDynamic)) );
            										}
            									}
            									else {
HXLINE( 149)										z1 = (z1 + partSize);
HXLINE( 150)										cInter = ((int)z1 & (int)(int)1);
HXLINE( 151)										pInter = hx::UShr(z1,(int)1);
            									}
HXLINE( 153)									pcount = (pcount + (int)1);
            								}
            								_hx_goto_6:;
            							}
HXLINE( 156)							classSet = (classSet + (int)1);
            						}
            					}
            					else {
HXLINE( 158)						if ((ch == (int)1)) {
HXLINE( 159)							while((pcount < partRead2)){
HXLINE( 161)								HX_VARI_NAME( int,cInter1,"cInter") = (int)0;
HXLINE( 162)								HX_VARI_NAME( int,pInter1,"pInter") = (this->begin + (pcount * partSize));
HXLINE( 163)								if ((pass == (int)0)) {
HXLINE( 164)									HX_VARI_NAME(  ::stb::format::vorbis::data::Codebook,c2,"c") = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,this->classbook)) );
HXLINE( 165)									if ((decodeState->validBits < (int)10)) {
HXLINE( 165)										decodeState->prepHuffman();
            									}
HXDLIN( 165)									HX_VARI_NAME( int,i2,"i") = ( (int)(_hx_array_unsafe_get(c2->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 165)									HX_VAR_NAME( int,val2,"val");
HXDLIN( 165)									if ((i2 >= (int)0)) {
HXLINE( 165)										HX_VARI_NAME( int,l1,"l") = ( (int)(_hx_array_unsafe_get(c2->codewordLengths,i2)) );
HXDLIN( 165)										decodeState->acc = hx::UShr(decodeState->acc,l1);
HXDLIN( 165)										decodeState->validBits = (decodeState->validBits - l1);
HXDLIN( 165)										if ((decodeState->validBits < (int)0)) {
HXLINE( 165)											decodeState->validBits = (int)0;
HXDLIN( 165)											val2 = (int)-1;
            										}
            										else {
HXLINE( 165)											val2 = i2;
            										}
            									}
            									else {
HXLINE( 165)										val2 = decodeState->decodeScalarRaw(c2);
            									}
HXDLIN( 165)									if (c2->sparse) {
HXLINE( 165)										val2 = ( (int)(_hx_array_unsafe_get(c2->sortedValues,val2)) );
            									}
HXDLIN( 165)									HX_VARI_NAME( int,q1,"q") = val2;
HXLINE( 166)									if ((q1 == (int)-1)) {
HXLINE( 166)										return;
            									}
HXLINE( 167)									{
HXLINE( 167)										::Array< int > val3 = ( (::Array< int >)(_hx_array_unsafe_get(this->classdata,q1)) );
HXDLIN( 167)										partClassdata->__unsafe_set(classSet,val3);
            									}
            								}
HXLINE( 170)								{
HXLINE( 170)									HX_VARI_NAME( int,_g22,"_g2") = (int)0;
HXDLIN( 170)									while((_g22 < classwords)){
HXLINE( 170)										_g22 = (_g22 + (int)1);
HXLINE( 171)										if ((pcount >= partRead2)) {
HXLINE( 172)											goto _hx_goto_8;
            										}
HXLINE( 174)										HX_VARI_NAME( int,z2,"z") = (this->begin + (pcount * partSize));
HXLINE( 175)										HX_VARI_NAME( int,c3,"c") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(partClassdata,classSet)) ),(_g22 - (int)1))) );
HXLINE( 176)										HX_VARI_NAME( int,b1,"b") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(this->residueBooks,c3)) ),pass)) );
HXLINE( 177)										if ((b1 >= (int)0)) {
HXLINE( 180)											HX_VARI_NAME(  ::Dynamic,result1,"result") = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,b1)) )->decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter1,pInter1,n,partSize);
HXLINE( 181)											if (hx::IsNull( result1 )) {
HXLINE( 182)												return;
            											}
            											else {
HXLINE( 184)												cInter1 = ( (int)(result1->__Field(HX_("cInter",b9,e7,a2,e6),hx::paccDynamic)) );
HXLINE( 185)												pInter1 = ( (int)(result1->__Field(HX_("pInter",8c,98,46,19),hx::paccDynamic)) );
            											}
            										}
            										else {
HXLINE( 189)											z2 = (z2 + partSize);
HXLINE( 190)											cInter1 = (int)0;
HXLINE( 191)											pInter1 = z2;
            										}
HXLINE( 193)										pcount = (pcount + (int)1);
            									}
            									_hx_goto_8:;
            								}
HXLINE( 195)								classSet = (classSet + (int)1);
            							}
            						}
            						else {
HXLINE( 198)							while((pcount < partRead2)){
HXLINE( 199)								HX_VARI_NAME( int,z3,"z") = (this->begin + (pcount * partSize));
HXLINE( 200)								HX_VARI_NAME( int,int2,"int") = z3;
HXDLIN( 200)								Float cInter2;
HXDLIN( 200)								if ((int2 < (int)0)) {
HXLINE( 200)									cInter2 = (((Float)4294967296.0) + int2);
            								}
            								else {
HXLINE( 200)									cInter2 = (int2 + ((Float)0.0));
            								}
HXDLIN( 200)								Float cInter3;
HXDLIN( 200)								if ((ch < (int)0)) {
HXLINE( 200)									cInter3 = (((Float)4294967296.0) + ch);
            								}
            								else {
HXLINE( 200)									cInter3 = (ch + ((Float)0.0));
            								}
HXDLIN( 200)								HX_VARI_NAME( int,cInter4,"cInter") = ::Std_obj::_hx_int(hx::Mod(cInter2,cInter3));
HXLINE( 201)								HX_VARI_NAME( int,int3,"int") = z3;
HXDLIN( 201)								Float pInter2;
HXDLIN( 201)								if ((int3 < (int)0)) {
HXLINE( 201)									pInter2 = (((Float)4294967296.0) + int3);
            								}
            								else {
HXLINE( 201)									pInter2 = (int3 + ((Float)0.0));
            								}
HXDLIN( 201)								Float pInter3;
HXDLIN( 201)								if ((ch < (int)0)) {
HXLINE( 201)									pInter3 = (((Float)4294967296.0) + ch);
            								}
            								else {
HXLINE( 201)									pInter3 = (ch + ((Float)0.0));
            								}
HXDLIN( 201)								HX_VARI_NAME( int,pInter4,"pInter") = ::Std_obj::_hx_int(((Float)pInter2 / (Float)pInter3));
HXLINE( 203)								if ((pass == (int)0)) {
HXLINE( 204)									HX_VARI_NAME(  ::stb::format::vorbis::data::Codebook,c4,"c") = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,this->classbook)) );
HXLINE( 205)									if ((decodeState->validBits < (int)10)) {
HXLINE( 205)										decodeState->prepHuffman();
            									}
HXDLIN( 205)									HX_VARI_NAME( int,i3,"i") = ( (int)(_hx_array_unsafe_get(c4->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 205)									HX_VAR_NAME( int,val4,"val");
HXDLIN( 205)									if ((i3 >= (int)0)) {
HXLINE( 205)										HX_VARI_NAME( int,l2,"l") = ( (int)(_hx_array_unsafe_get(c4->codewordLengths,i3)) );
HXDLIN( 205)										decodeState->acc = hx::UShr(decodeState->acc,l2);
HXDLIN( 205)										decodeState->validBits = (decodeState->validBits - l2);
HXDLIN( 205)										if ((decodeState->validBits < (int)0)) {
HXLINE( 205)											decodeState->validBits = (int)0;
HXDLIN( 205)											val4 = (int)-1;
            										}
            										else {
HXLINE( 205)											val4 = i3;
            										}
            									}
            									else {
HXLINE( 205)										val4 = decodeState->decodeScalarRaw(c4);
            									}
HXDLIN( 205)									if (c4->sparse) {
HXLINE( 205)										val4 = ( (int)(_hx_array_unsafe_get(c4->sortedValues,val4)) );
            									}
HXDLIN( 205)									HX_VARI_NAME( int,q2,"q") = val4;
HXLINE( 206)									if ((q2 == (int)-1)) {
HXLINE( 207)										return;
            									}
HXLINE( 209)									{
HXLINE( 209)										::Array< int > val5 = ( (::Array< int >)(_hx_array_unsafe_get(this->classdata,q2)) );
HXDLIN( 209)										partClassdata->__unsafe_set(classSet,val5);
            									}
            								}
HXLINE( 212)								{
HXLINE( 212)									HX_VARI_NAME( int,_g23,"_g2") = (int)0;
HXDLIN( 212)									while((_g23 < classwords)){
HXLINE( 212)										_g23 = (_g23 + (int)1);
HXLINE( 213)										if ((pcount >= partRead2)) {
HXLINE( 214)											goto _hx_goto_10;
            										}
HXLINE( 216)										HX_VARI_NAME( int,z4,"z") = (this->begin + (pcount * partSize));
HXLINE( 217)										HX_VARI_NAME( int,c5,"c") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(partClassdata,classSet)) ),(_g23 - (int)1))) );
HXLINE( 218)										HX_VARI_NAME( int,b2,"b") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(this->residueBooks,c5)) ),pass)) );
HXLINE( 219)										if ((b2 >= (int)0)) {
HXLINE( 222)											HX_VARI_NAME(  ::Dynamic,result2,"result") = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,b2)) )->decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter4,pInter4,n,partSize);
HXLINE( 223)											if (hx::IsNull( result2 )) {
HXLINE( 224)												return;
            											}
            											else {
HXLINE( 226)												cInter4 = ( (int)(result2->__Field(HX_("cInter",b9,e7,a2,e6),hx::paccDynamic)) );
HXLINE( 227)												pInter4 = ( (int)(result2->__Field(HX_("pInter",8c,98,46,19),hx::paccDynamic)) );
            											}
            										}
            										else {
HXLINE( 231)											z4 = (z4 + partSize);
HXLINE( 232)											HX_VARI_NAME( int,int4,"int") = z4;
HXDLIN( 232)											Float cInter5;
HXDLIN( 232)											if ((int4 < (int)0)) {
HXLINE( 232)												cInter5 = (((Float)4294967296.0) + int4);
            											}
            											else {
HXLINE( 232)												cInter5 = (int4 + ((Float)0.0));
            											}
HXDLIN( 232)											Float cInter6;
HXDLIN( 232)											if ((ch < (int)0)) {
HXLINE( 232)												cInter6 = (((Float)4294967296.0) + ch);
            											}
            											else {
HXLINE( 232)												cInter6 = (ch + ((Float)0.0));
            											}
HXDLIN( 232)											cInter4 = ::Std_obj::_hx_int(hx::Mod(cInter5,cInter6));
HXLINE( 233)											HX_VARI_NAME( int,int5,"int") = z4;
HXDLIN( 233)											Float pInter5;
HXDLIN( 233)											if ((int5 < (int)0)) {
HXLINE( 233)												pInter5 = (((Float)4294967296.0) + int5);
            											}
            											else {
HXLINE( 233)												pInter5 = (int5 + ((Float)0.0));
            											}
HXDLIN( 233)											Float pInter6;
HXDLIN( 233)											if ((ch < (int)0)) {
HXLINE( 233)												pInter6 = (((Float)4294967296.0) + ch);
            											}
            											else {
HXLINE( 233)												pInter6 = (ch + ((Float)0.0));
            											}
HXDLIN( 233)											pInter4 = ::Std_obj::_hx_int(((Float)pInter5 / (Float)pInter6));
            										}
HXLINE( 235)										pcount = (pcount + (int)1);
            									}
            									_hx_goto_10:;
            								}
HXLINE( 237)								classSet = (classSet + (int)1);
            							}
            						}
            					}
            				}
            			}
HXLINE( 241)			return;
            		}
HXLINE( 245)		{
HXLINE( 245)			HX_VARI_NAME( int,_g4,"_g") = (int)0;
HXDLIN( 245)			while((_g4 < (int)8)){
HXLINE( 245)				_g4 = (_g4 + (int)1);
HXDLIN( 245)				HX_VARI_NAME( int,pass1,"pass") = (_g4 - (int)1);
HXLINE( 246)				HX_VARI_NAME( int,pcount1,"pcount") = (int)0;
HXLINE( 247)				HX_VARI_NAME( int,classSet1,"classSet") = (int)0;
HXLINE( 248)				while((pcount1 < partRead2)){
HXLINE( 249)					if ((pass1 == (int)0)) {
HXLINE( 250)						HX_VARI_NAME( int,_g24,"_g2") = (int)0;
HXDLIN( 250)						while((_g24 < ch)){
HXLINE( 250)							_g24 = (_g24 + (int)1);
HXDLIN( 250)							HX_VARI_NAME( int,j1,"j") = (_g24 - (int)1);
HXLINE( 251)							if (!(( (bool)(_hx_array_unsafe_get(doNotDecode,j1)) ))) {
HXLINE( 252)								HX_VARI_NAME(  ::stb::format::vorbis::data::Codebook,c6,"c") = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,this->classbook)) );
HXLINE( 253)								if ((decodeState->validBits < (int)10)) {
HXLINE( 253)									decodeState->prepHuffman();
            								}
HXDLIN( 253)								HX_VARI_NAME( int,i4,"i") = ( (int)(_hx_array_unsafe_get(c6->fastHuffman,((int)decodeState->acc & (int)(int)1023))) );
HXDLIN( 253)								HX_VAR_NAME( int,val6,"val");
HXDLIN( 253)								if ((i4 >= (int)0)) {
HXLINE( 253)									HX_VARI_NAME( int,l3,"l") = ( (int)(_hx_array_unsafe_get(c6->codewordLengths,i4)) );
HXDLIN( 253)									decodeState->acc = hx::UShr(decodeState->acc,l3);
HXDLIN( 253)									decodeState->validBits = (decodeState->validBits - l3);
HXDLIN( 253)									if ((decodeState->validBits < (int)0)) {
HXLINE( 253)										decodeState->validBits = (int)0;
HXDLIN( 253)										val6 = (int)-1;
            									}
            									else {
HXLINE( 253)										val6 = i4;
            									}
            								}
            								else {
HXLINE( 253)									val6 = decodeState->decodeScalarRaw(c6);
            								}
HXDLIN( 253)								if (c6->sparse) {
HXLINE( 253)									val6 = ( (int)(_hx_array_unsafe_get(c6->sortedValues,val6)) );
            								}
HXDLIN( 253)								HX_VARI( int,temp) = val6;
HXLINE( 254)								if ((temp == (int)-1)) {
HXLINE( 255)									return;
            								}
HXLINE( 257)								{
HXLINE( 257)									::Array< int > val7 = ( (::Array< int >)(_hx_array_unsafe_get(this->classdata,temp)) );
HXDLIN( 257)									partClassdata->__unsafe_set(((j1 * partRead2) + classSet1),val7);
            								}
            							}
            						}
            					}
HXLINE( 261)					{
HXLINE( 261)						HX_VARI_NAME( int,_g25,"_g2") = (int)0;
HXDLIN( 261)						while((_g25 < classwords)){
HXLINE( 261)							_g25 = (_g25 + (int)1);
HXDLIN( 261)							HX_VARI_NAME( int,i5,"i") = (_g25 - (int)1);
HXLINE( 262)							if ((pcount1 >= partRead2)) {
HXLINE( 263)								goto _hx_goto_14;
            							}
HXLINE( 265)							{
HXLINE( 265)								HX_VARI_NAME( int,_g41,"_g4") = (int)0;
HXDLIN( 265)								while((_g41 < ch)){
HXLINE( 265)									_g41 = (_g41 + (int)1);
HXDLIN( 265)									HX_VARI_NAME( int,j2,"j") = (_g41 - (int)1);
HXLINE( 266)									if (!(( (bool)(_hx_array_unsafe_get(doNotDecode,j2)) ))) {
HXLINE( 267)										HX_VARI_NAME( int,c7,"c") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(partClassdata,((j2 * partRead2) + classSet1))) ),i5)) );
HXLINE( 268)										HX_VARI_NAME( int,b3,"b") = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(this->residueBooks,c7)) ),pass1)) );
HXLINE( 269)										if ((b3 >= (int)0)) {
HXLINE( 270)											HX_VARI( ::Array< Float >,target) = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,j2)) );
HXLINE( 271)											HX_VARI( int,offset) = (this->begin + (pcount1 * partSize));
HXLINE( 273)											HX_VARI(  ::stb::format::vorbis::data::Codebook,book) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,b3)) );
HXLINE( 274)											if (!(book->residueDecode(decodeState,target,offset,partSize,this->type))) {
HXLINE( 275)												return;
            											}
            										}
            									}
            								}
            							}
HXLINE( 280)							pcount1 = (pcount1 + (int)1);
            						}
            						_hx_goto_14:;
            					}
HXLINE( 282)					classSet1 = (classSet1 + (int)1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(Residue_obj,decode,(void))

 ::stb::format::vorbis::data::Residue Residue_obj::read( ::stb::format::vorbis::VorbisDecodeState decodeState,::Array< ::Dynamic> codebooks){
            	HX_GC_STACKFRAME(&_hx_pos_b00c91391853c156_25_read)
            	HX_STACK_ARG(decodeState,"decodeState")
            	HX_STACK_ARG(codebooks,"codebooks")
HXLINE(  26)		HX_VARI(  ::stb::format::vorbis::data::Residue,r) =  ::stb::format::vorbis::data::Residue_obj::__alloc( HX_CTX );
HXLINE(  27)		int _hx_tmp;
HXDLIN(  27)		if ((decodeState->validBits < (int)0)) {
HXLINE(  27)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE(  27)			if ((decodeState->validBits < (int)16)) {
HXLINE(  27)				if ((decodeState->validBits == (int)0)) {
HXLINE(  27)					decodeState->acc = (int)0;
            				}
HXDLIN(  27)				while(true){
HXLINE(  27)					bool _hx_tmp1;
HXDLIN(  27)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  27)						if (!(decodeState->lastSeg)) {
HXLINE(  27)							_hx_tmp1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  27)							_hx_tmp1 = true;
            						}
            					}
            					else {
HXLINE(  27)						_hx_tmp1 = false;
            					}
HXDLIN(  27)					if (_hx_tmp1) {
HXLINE(  27)						decodeState->validBits = (int)-1;
HXDLIN(  27)						goto _hx_goto_17;
            					}
            					else {
HXLINE(  27)						decodeState->bytesInSeg--;
HXDLIN(  27)						int a = decodeState->acc;
HXDLIN(  27)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  27)						int b = decodeState->input->readByte();
HXDLIN(  27)						decodeState->acc = (a + ((int)b << (int)decodeState->validBits));
HXDLIN(  27)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  27)					if (!((decodeState->validBits < (int)16))) {
HXLINE(  27)						goto _hx_goto_17;
            					}
            				}
            				_hx_goto_17:;
HXDLIN(  27)				if ((decodeState->validBits < (int)0)) {
HXLINE(  27)					_hx_tmp = (int)0;
            				}
            				else {
HXLINE(  27)					HX_VARI( int,z) = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  27)					decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  27)					decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  27)					_hx_tmp = z;
            				}
            			}
            			else {
HXLINE(  27)				HX_VARI_NAME( int,z1,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  27)				decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  27)				decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  27)				_hx_tmp = z1;
            			}
            		}
HXDLIN(  27)		r->type = _hx_tmp;
HXLINE(  28)		if ((r->type > (int)2)) {
HXLINE(  29)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Residue.hx",73,8f,87,2d),29,HX_("stb.format.vorbis.data.Residue",d8,c5,5d,30),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  32)		HX_VARI( ::Array< int >,residueCascade) = ::Array_obj< int >::__new((int)64);
HXLINE(  33)		int _hx_tmp2;
HXDLIN(  33)		if ((decodeState->validBits < (int)0)) {
HXLINE(  33)			_hx_tmp2 = (int)0;
            		}
            		else {
HXLINE(  33)			if ((decodeState->validBits < (int)24)) {
HXLINE(  33)				if ((decodeState->validBits == (int)0)) {
HXLINE(  33)					decodeState->acc = (int)0;
            				}
HXDLIN(  33)				while(true){
HXLINE(  33)					bool _hx_tmp3;
HXDLIN(  33)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  33)						if (!(decodeState->lastSeg)) {
HXLINE(  33)							_hx_tmp3 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  33)							_hx_tmp3 = true;
            						}
            					}
            					else {
HXLINE(  33)						_hx_tmp3 = false;
            					}
HXDLIN(  33)					if (_hx_tmp3) {
HXLINE(  33)						decodeState->validBits = (int)-1;
HXDLIN(  33)						goto _hx_goto_18;
            					}
            					else {
HXLINE(  33)						decodeState->bytesInSeg--;
HXDLIN(  33)						int a1 = decodeState->acc;
HXDLIN(  33)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  33)						int b1 = decodeState->input->readByte();
HXDLIN(  33)						decodeState->acc = (a1 + ((int)b1 << (int)decodeState->validBits));
HXDLIN(  33)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  33)					if (!((decodeState->validBits < (int)24))) {
HXLINE(  33)						goto _hx_goto_18;
            					}
            				}
            				_hx_goto_18:;
HXDLIN(  33)				if ((decodeState->validBits < (int)0)) {
HXLINE(  33)					_hx_tmp2 = (int)0;
            				}
            				else {
HXLINE(  33)					HX_VARI_NAME( int,z2,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  33)					decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  33)					decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  33)					_hx_tmp2 = z2;
            				}
            			}
            			else {
HXLINE(  33)				HX_VARI_NAME( int,z3,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  33)				decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  33)				decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  33)				_hx_tmp2 = z3;
            			}
            		}
HXDLIN(  33)		r->begin = _hx_tmp2;
HXLINE(  34)		int _hx_tmp4;
HXDLIN(  34)		if ((decodeState->validBits < (int)0)) {
HXLINE(  34)			_hx_tmp4 = (int)0;
            		}
            		else {
HXLINE(  34)			if ((decodeState->validBits < (int)24)) {
HXLINE(  34)				if ((decodeState->validBits == (int)0)) {
HXLINE(  34)					decodeState->acc = (int)0;
            				}
HXDLIN(  34)				while(true){
HXLINE(  34)					bool _hx_tmp5;
HXDLIN(  34)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  34)						if (!(decodeState->lastSeg)) {
HXLINE(  34)							_hx_tmp5 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  34)							_hx_tmp5 = true;
            						}
            					}
            					else {
HXLINE(  34)						_hx_tmp5 = false;
            					}
HXDLIN(  34)					if (_hx_tmp5) {
HXLINE(  34)						decodeState->validBits = (int)-1;
HXDLIN(  34)						goto _hx_goto_19;
            					}
            					else {
HXLINE(  34)						decodeState->bytesInSeg--;
HXDLIN(  34)						int a2 = decodeState->acc;
HXDLIN(  34)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  34)						int b2 = decodeState->input->readByte();
HXDLIN(  34)						decodeState->acc = (a2 + ((int)b2 << (int)decodeState->validBits));
HXDLIN(  34)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  34)					if (!((decodeState->validBits < (int)24))) {
HXLINE(  34)						goto _hx_goto_19;
            					}
            				}
            				_hx_goto_19:;
HXDLIN(  34)				if ((decodeState->validBits < (int)0)) {
HXLINE(  34)					_hx_tmp4 = (int)0;
            				}
            				else {
HXLINE(  34)					HX_VARI_NAME( int,z4,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  34)					decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  34)					decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  34)					_hx_tmp4 = z4;
            				}
            			}
            			else {
HXLINE(  34)				HX_VARI_NAME( int,z5,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  34)				decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  34)				decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  34)				_hx_tmp4 = z5;
            			}
            		}
HXDLIN(  34)		r->end = _hx_tmp4;
HXLINE(  35)		int _hx_tmp6;
HXDLIN(  35)		if ((decodeState->validBits < (int)0)) {
HXLINE(  35)			_hx_tmp6 = (int)0;
            		}
            		else {
HXLINE(  35)			if ((decodeState->validBits < (int)24)) {
HXLINE(  35)				if ((decodeState->validBits == (int)0)) {
HXLINE(  35)					decodeState->acc = (int)0;
            				}
HXDLIN(  35)				while(true){
HXLINE(  35)					bool _hx_tmp7;
HXDLIN(  35)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  35)						if (!(decodeState->lastSeg)) {
HXLINE(  35)							_hx_tmp7 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  35)							_hx_tmp7 = true;
            						}
            					}
            					else {
HXLINE(  35)						_hx_tmp7 = false;
            					}
HXDLIN(  35)					if (_hx_tmp7) {
HXLINE(  35)						decodeState->validBits = (int)-1;
HXDLIN(  35)						goto _hx_goto_20;
            					}
            					else {
HXLINE(  35)						decodeState->bytesInSeg--;
HXDLIN(  35)						int a3 = decodeState->acc;
HXDLIN(  35)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  35)						int b3 = decodeState->input->readByte();
HXDLIN(  35)						decodeState->acc = (a3 + ((int)b3 << (int)decodeState->validBits));
HXDLIN(  35)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  35)					if (!((decodeState->validBits < (int)24))) {
HXLINE(  35)						goto _hx_goto_20;
            					}
            				}
            				_hx_goto_20:;
HXDLIN(  35)				if ((decodeState->validBits < (int)0)) {
HXLINE(  35)					_hx_tmp6 = (int)0;
            				}
            				else {
HXLINE(  35)					HX_VARI_NAME( int,z6,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  35)					decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  35)					decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  35)					_hx_tmp6 = z6;
            				}
            			}
            			else {
HXLINE(  35)				HX_VARI_NAME( int,z7,"z") = ((int)decodeState->acc & (int)(int)16777215);
HXDLIN(  35)				decodeState->acc = hx::UShr(decodeState->acc,(int)24);
HXDLIN(  35)				decodeState->validBits = (decodeState->validBits - (int)24);
HXDLIN(  35)				_hx_tmp6 = z7;
            			}
            		}
HXDLIN(  35)		r->partSize = (_hx_tmp6 + (int)1);
HXLINE(  36)		int classifications;
HXDLIN(  36)		if ((decodeState->validBits < (int)0)) {
HXLINE(  36)			classifications = (int)0;
            		}
            		else {
HXLINE(  36)			if ((decodeState->validBits < (int)6)) {
HXLINE(  36)				if ((decodeState->validBits == (int)0)) {
HXLINE(  36)					decodeState->acc = (int)0;
            				}
HXDLIN(  36)				while(true){
HXLINE(  36)					bool classifications1;
HXDLIN(  36)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  36)						if (!(decodeState->lastSeg)) {
HXLINE(  36)							classifications1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  36)							classifications1 = true;
            						}
            					}
            					else {
HXLINE(  36)						classifications1 = false;
            					}
HXDLIN(  36)					if (classifications1) {
HXLINE(  36)						decodeState->validBits = (int)-1;
HXDLIN(  36)						goto _hx_goto_21;
            					}
            					else {
HXLINE(  36)						decodeState->bytesInSeg--;
HXDLIN(  36)						int a4 = decodeState->acc;
HXDLIN(  36)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  36)						int b4 = decodeState->input->readByte();
HXDLIN(  36)						decodeState->acc = (a4 + ((int)b4 << (int)decodeState->validBits));
HXDLIN(  36)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  36)					if (!((decodeState->validBits < (int)6))) {
HXLINE(  36)						goto _hx_goto_21;
            					}
            				}
            				_hx_goto_21:;
HXDLIN(  36)				if ((decodeState->validBits < (int)0)) {
HXLINE(  36)					classifications = (int)0;
            				}
            				else {
HXLINE(  36)					HX_VARI_NAME( int,z8,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN(  36)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN(  36)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN(  36)					classifications = z8;
            				}
            			}
            			else {
HXLINE(  36)				HX_VARI_NAME( int,z9,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN(  36)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN(  36)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN(  36)				classifications = z9;
            			}
            		}
HXDLIN(  36)		HX_VARI_NAME( int,classifications2,"classifications") = (r->classifications = (classifications + (int)1));
HXLINE(  37)		int _hx_tmp8;
HXDLIN(  37)		if ((decodeState->validBits < (int)0)) {
HXLINE(  37)			_hx_tmp8 = (int)0;
            		}
            		else {
HXLINE(  37)			if ((decodeState->validBits < (int)8)) {
HXLINE(  37)				if ((decodeState->validBits == (int)0)) {
HXLINE(  37)					decodeState->acc = (int)0;
            				}
HXDLIN(  37)				while(true){
HXLINE(  37)					bool _hx_tmp9;
HXDLIN(  37)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  37)						if (!(decodeState->lastSeg)) {
HXLINE(  37)							_hx_tmp9 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  37)							_hx_tmp9 = true;
            						}
            					}
            					else {
HXLINE(  37)						_hx_tmp9 = false;
            					}
HXDLIN(  37)					if (_hx_tmp9) {
HXLINE(  37)						decodeState->validBits = (int)-1;
HXDLIN(  37)						goto _hx_goto_22;
            					}
            					else {
HXLINE(  37)						decodeState->bytesInSeg--;
HXDLIN(  37)						int a5 = decodeState->acc;
HXDLIN(  37)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  37)						int b5 = decodeState->input->readByte();
HXDLIN(  37)						decodeState->acc = (a5 + ((int)b5 << (int)decodeState->validBits));
HXDLIN(  37)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  37)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  37)						goto _hx_goto_22;
            					}
            				}
            				_hx_goto_22:;
HXDLIN(  37)				if ((decodeState->validBits < (int)0)) {
HXLINE(  37)					_hx_tmp8 = (int)0;
            				}
            				else {
HXLINE(  37)					HX_VARI_NAME( int,z10,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  37)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  37)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  37)					_hx_tmp8 = z10;
            				}
            			}
            			else {
HXLINE(  37)				HX_VARI_NAME( int,z11,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  37)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  37)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  37)				_hx_tmp8 = z11;
            			}
            		}
HXDLIN(  37)		r->classbook = _hx_tmp8;
HXLINE(  39)		{
HXLINE(  39)			HX_VARI( int,_g1) = (int)0;
HXDLIN(  39)			HX_VARI( int,_g) = r->classifications;
HXDLIN(  39)			while((_g1 < _g)){
HXLINE(  39)				_g1 = (_g1 + (int)1);
HXDLIN(  39)				HX_VARI( int,j) = (_g1 - (int)1);
HXLINE(  40)				HX_VARI( int,highBits) = (int)0;
HXLINE(  41)				HX_VAR( int,lowBits);
HXDLIN(  41)				if ((decodeState->validBits < (int)0)) {
HXLINE(  41)					lowBits = (int)0;
            				}
            				else {
HXLINE(  41)					if ((decodeState->validBits < (int)3)) {
HXLINE(  41)						if ((decodeState->validBits == (int)0)) {
HXLINE(  41)							decodeState->acc = (int)0;
            						}
HXDLIN(  41)						while(true){
HXLINE(  41)							bool lowBits1;
HXDLIN(  41)							if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  41)								if (!(decodeState->lastSeg)) {
HXLINE(  41)									lowBits1 = (decodeState->next() == (int)0);
            								}
            								else {
HXLINE(  41)									lowBits1 = true;
            								}
            							}
            							else {
HXLINE(  41)								lowBits1 = false;
            							}
HXDLIN(  41)							if (lowBits1) {
HXLINE(  41)								decodeState->validBits = (int)-1;
HXDLIN(  41)								goto _hx_goto_24;
            							}
            							else {
HXLINE(  41)								decodeState->bytesInSeg--;
HXDLIN(  41)								int a6 = decodeState->acc;
HXDLIN(  41)								decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  41)								int b6 = decodeState->input->readByte();
HXDLIN(  41)								decodeState->acc = (a6 + ((int)b6 << (int)decodeState->validBits));
HXDLIN(  41)								decodeState->validBits = (decodeState->validBits + (int)8);
            							}
HXDLIN(  41)							if (!((decodeState->validBits < (int)3))) {
HXLINE(  41)								goto _hx_goto_24;
            							}
            						}
            						_hx_goto_24:;
HXDLIN(  41)						if ((decodeState->validBits < (int)0)) {
HXLINE(  41)							lowBits = (int)0;
            						}
            						else {
HXLINE(  41)							HX_VARI_NAME( int,z12,"z") = ((int)decodeState->acc & (int)(int)7);
HXDLIN(  41)							decodeState->acc = hx::UShr(decodeState->acc,(int)3);
HXDLIN(  41)							decodeState->validBits = (decodeState->validBits - (int)3);
HXDLIN(  41)							lowBits = z12;
            						}
            					}
            					else {
HXLINE(  41)						HX_VARI_NAME( int,z13,"z") = ((int)decodeState->acc & (int)(int)7);
HXDLIN(  41)						decodeState->acc = hx::UShr(decodeState->acc,(int)3);
HXDLIN(  41)						decodeState->validBits = (decodeState->validBits - (int)3);
HXDLIN(  41)						lowBits = z13;
            					}
            				}
HXLINE(  42)				int _hx_tmp10;
HXDLIN(  42)				if ((decodeState->validBits < (int)0)) {
HXLINE(  42)					_hx_tmp10 = (int)0;
            				}
            				else {
HXLINE(  42)					if ((decodeState->validBits < (int)1)) {
HXLINE(  42)						if ((decodeState->validBits == (int)0)) {
HXLINE(  42)							decodeState->acc = (int)0;
            						}
HXDLIN(  42)						while(true){
HXLINE(  42)							bool _hx_tmp11;
HXDLIN(  42)							if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  42)								if (!(decodeState->lastSeg)) {
HXLINE(  42)									_hx_tmp11 = (decodeState->next() == (int)0);
            								}
            								else {
HXLINE(  42)									_hx_tmp11 = true;
            								}
            							}
            							else {
HXLINE(  42)								_hx_tmp11 = false;
            							}
HXDLIN(  42)							if (_hx_tmp11) {
HXLINE(  42)								decodeState->validBits = (int)-1;
HXDLIN(  42)								goto _hx_goto_25;
            							}
            							else {
HXLINE(  42)								decodeState->bytesInSeg--;
HXDLIN(  42)								int a7 = decodeState->acc;
HXDLIN(  42)								decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  42)								int b7 = decodeState->input->readByte();
HXDLIN(  42)								decodeState->acc = (a7 + ((int)b7 << (int)decodeState->validBits));
HXDLIN(  42)								decodeState->validBits = (decodeState->validBits + (int)8);
            							}
HXDLIN(  42)							if (!((decodeState->validBits < (int)1))) {
HXLINE(  42)								goto _hx_goto_25;
            							}
            						}
            						_hx_goto_25:;
HXDLIN(  42)						if ((decodeState->validBits < (int)0)) {
HXLINE(  42)							_hx_tmp10 = (int)0;
            						}
            						else {
HXLINE(  42)							HX_VARI_NAME( int,z14,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  42)							decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  42)							decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  42)							_hx_tmp10 = z14;
            						}
            					}
            					else {
HXLINE(  42)						HX_VARI_NAME( int,z15,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  42)						decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  42)						decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  42)						_hx_tmp10 = z15;
            					}
            				}
HXDLIN(  42)				if ((_hx_tmp10 != (int)0)) {
HXLINE(  43)					if ((decodeState->validBits < (int)0)) {
HXLINE(  43)						highBits = (int)0;
            					}
            					else {
HXLINE(  43)						if ((decodeState->validBits < (int)5)) {
HXLINE(  43)							if ((decodeState->validBits == (int)0)) {
HXLINE(  43)								decodeState->acc = (int)0;
            							}
HXDLIN(  43)							while(true){
HXLINE(  43)								bool highBits1;
HXDLIN(  43)								if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  43)									if (!(decodeState->lastSeg)) {
HXLINE(  43)										highBits1 = (decodeState->next() == (int)0);
            									}
            									else {
HXLINE(  43)										highBits1 = true;
            									}
            								}
            								else {
HXLINE(  43)									highBits1 = false;
            								}
HXDLIN(  43)								if (highBits1) {
HXLINE(  43)									decodeState->validBits = (int)-1;
HXDLIN(  43)									goto _hx_goto_26;
            								}
            								else {
HXLINE(  43)									decodeState->bytesInSeg--;
HXDLIN(  43)									int a8 = decodeState->acc;
HXDLIN(  43)									decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  43)									int b8 = decodeState->input->readByte();
HXDLIN(  43)									decodeState->acc = (a8 + ((int)b8 << (int)decodeState->validBits));
HXDLIN(  43)									decodeState->validBits = (decodeState->validBits + (int)8);
            								}
HXDLIN(  43)								if (!((decodeState->validBits < (int)5))) {
HXLINE(  43)									goto _hx_goto_26;
            								}
            							}
            							_hx_goto_26:;
HXDLIN(  43)							if ((decodeState->validBits < (int)0)) {
HXLINE(  43)								highBits = (int)0;
            							}
            							else {
HXLINE(  43)								HX_VARI_NAME( int,z16,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  43)								decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  43)								decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  43)								highBits = z16;
            							}
            						}
            						else {
HXLINE(  43)							HX_VARI_NAME( int,z17,"z") = ((int)decodeState->acc & (int)(int)31);
HXDLIN(  43)							decodeState->acc = hx::UShr(decodeState->acc,(int)5);
HXDLIN(  43)							decodeState->validBits = (decodeState->validBits - (int)5);
HXDLIN(  43)							highBits = z17;
            						}
            					}
            				}
HXLINE(  45)				residueCascade->__unsafe_set(j,((highBits * (int)8) + lowBits));
            			}
            		}
HXLINE(  48)		r->residueBooks = ::Array_obj< ::Dynamic>::__new(r->classifications);
HXLINE(  49)		{
HXLINE(  49)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN(  49)			HX_VARI_NAME( int,_g2,"_g") = r->classifications;
HXDLIN(  49)			while((_g11 < _g2)){
HXLINE(  49)				_g11 = (_g11 + (int)1);
HXDLIN(  49)				HX_VARI_NAME( int,j1,"j") = (_g11 - (int)1);
HXLINE(  50)				{
HXLINE(  50)					::Array< ::Dynamic> this1 = r->residueBooks;
HXDLIN(  50)					HX_VARI_NAME( ::Array< int >,this2,"this") = ::Array_obj< int >::__new((int)8);
HXDLIN(  50)					this1->__unsafe_set(j1,this2);
            				}
HXLINE(  51)				{
HXLINE(  51)					HX_VARI_NAME( int,_g21,"_g2") = (int)0;
HXDLIN(  51)					while((_g21 < (int)8)){
HXLINE(  51)						_g21 = (_g21 + (int)1);
HXDLIN(  51)						HX_VARI( int,k) = (_g21 - (int)1);
HXLINE(  52)						if ((((int)( (int)(_hx_array_unsafe_get(residueCascade,j1)) ) & (int)((int)(int)1 << (int)k)) != (int)0)) {
HXLINE(  53)							{
HXLINE(  53)								::Array< int > this3 = ( (::Array< int >)(_hx_array_unsafe_get(r->residueBooks,j1)) );
HXDLIN(  53)								int val;
HXDLIN(  53)								if ((decodeState->validBits < (int)0)) {
HXLINE(  53)									val = (int)0;
            								}
            								else {
HXLINE(  53)									if ((decodeState->validBits < (int)8)) {
HXLINE(  53)										if ((decodeState->validBits == (int)0)) {
HXLINE(  53)											decodeState->acc = (int)0;
            										}
HXDLIN(  53)										while(true){
HXLINE(  53)											bool val1;
HXDLIN(  53)											if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  53)												if (!(decodeState->lastSeg)) {
HXLINE(  53)													val1 = (decodeState->next() == (int)0);
            												}
            												else {
HXLINE(  53)													val1 = true;
            												}
            											}
            											else {
HXLINE(  53)												val1 = false;
            											}
HXDLIN(  53)											if (val1) {
HXLINE(  53)												decodeState->validBits = (int)-1;
HXDLIN(  53)												goto _hx_goto_29;
            											}
            											else {
HXLINE(  53)												decodeState->bytesInSeg--;
HXDLIN(  53)												int a9 = decodeState->acc;
HXDLIN(  53)												decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  53)												int b9 = decodeState->input->readByte();
HXDLIN(  53)												decodeState->acc = (a9 + ((int)b9 << (int)decodeState->validBits));
HXDLIN(  53)												decodeState->validBits = (decodeState->validBits + (int)8);
            											}
HXDLIN(  53)											if (!((decodeState->validBits < (int)8))) {
HXLINE(  53)												goto _hx_goto_29;
            											}
            										}
            										_hx_goto_29:;
HXDLIN(  53)										if ((decodeState->validBits < (int)0)) {
HXLINE(  53)											val = (int)0;
            										}
            										else {
HXLINE(  53)											HX_VARI_NAME( int,z18,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  53)											decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  53)											decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  53)											val = z18;
            										}
            									}
            									else {
HXLINE(  53)										HX_VARI_NAME( int,z19,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  53)										decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  53)										decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  53)										val = z19;
            									}
            								}
HXDLIN(  53)								this3->__unsafe_set(k,val);
            							}
HXLINE(  54)							int _hx_tmp12 = ( (int)(_hx_array_unsafe_get(( (::Array< int >)(_hx_array_unsafe_get(r->residueBooks,j1)) ),k)) );
HXDLIN(  54)							if ((_hx_tmp12 >= codebooks->length)) {
HXLINE(  55)								HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Residue.hx",73,8f,87,2d),55,HX_("stb.format.vorbis.data.Residue",d8,c5,5d,30),HX_("read",56,4b,a7,4b))));
            							}
            						}
            						else {
HXLINE(  58)							( (::Array< int >)(_hx_array_unsafe_get(r->residueBooks,j1)) )->__unsafe_set(k,(int)-1);
            						}
            					}
            				}
            			}
            		}
HXLINE(  65)		HX_VARI( int,el) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,r->classbook)) )->entries;
HXLINE(  66)		HX_VARI( int,classwords) = ( ( ::stb::format::vorbis::data::Codebook)(_hx_array_unsafe_get(codebooks,r->classbook)) )->dimensions;
HXLINE(  67)		r->classdata = ::Array_obj< ::Dynamic>::__new(el);
HXLINE(  69)		{
HXLINE(  69)			HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN(  69)			while((_g12 < el)){
HXLINE(  69)				_g12 = (_g12 + (int)1);
HXDLIN(  69)				HX_VARI_NAME( int,j2,"j") = (_g12 - (int)1);
HXLINE(  70)				HX_VARI( int,temp) = j2;
HXLINE(  71)				HX_VARI_NAME( int,k1,"k") = classwords;
HXLINE(  72)				::Array< ::Dynamic> this4 = r->classdata;
HXDLIN(  72)				HX_VARI_NAME( ::Array< int >,this5,"this") = ::Array_obj< int >::__new(classwords);
HXDLIN(  72)				HX_VARI( ::Array< int >,cd) = this4->__unsafe_set(j2,this5).StaticCast< ::Array< int > >();
HXLINE(  73)				while(true){
HXLINE(  73)					k1 = (k1 - (int)1);
HXDLIN(  73)					if (!((k1 >= (int)0))) {
HXLINE(  73)						goto _hx_goto_31;
            					}
HXLINE(  74)					cd->__unsafe_set(k1,hx::Mod(temp,classifications2));
HXLINE(  75)					temp = ::Std_obj::_hx_int(((Float)temp / (Float)classifications2));
            				}
            				_hx_goto_31:;
            			}
            		}
HXLINE(  79)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Residue_obj,read,return )


hx::ObjectPtr< Residue_obj > Residue_obj::__new() {
	hx::ObjectPtr< Residue_obj > __this = new Residue_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Residue_obj > Residue_obj::__alloc(hx::Ctx *_hx_ctx) {
	Residue_obj *__this = (Residue_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Residue_obj), true, "stb.format.vorbis.data.Residue"));
	*(void **)__this = Residue_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Residue_obj::Residue_obj()
{
}

void Residue_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Residue);
	HX_MARK_MEMBER_NAME(begin,"begin");
	HX_MARK_MEMBER_NAME(end,"end");
	HX_MARK_MEMBER_NAME(partSize,"partSize");
	HX_MARK_MEMBER_NAME(classifications,"classifications");
	HX_MARK_MEMBER_NAME(classbook,"classbook");
	HX_MARK_MEMBER_NAME(classdata,"classdata");
	HX_MARK_MEMBER_NAME(residueBooks,"residueBooks");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_END_CLASS();
}

void Residue_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(begin,"begin");
	HX_VISIT_MEMBER_NAME(end,"end");
	HX_VISIT_MEMBER_NAME(partSize,"partSize");
	HX_VISIT_MEMBER_NAME(classifications,"classifications");
	HX_VISIT_MEMBER_NAME(classbook,"classbook");
	HX_VISIT_MEMBER_NAME(classdata,"classdata");
	HX_VISIT_MEMBER_NAME(residueBooks,"residueBooks");
	HX_VISIT_MEMBER_NAME(type,"type");
}

hx::Val Residue_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return hx::Val( end); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"begin") ) { return hx::Val( begin); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"decode") ) { return hx::Val( decode_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"partSize") ) { return hx::Val( partSize); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"classbook") ) { return hx::Val( classbook); }
		if (HX_FIELD_EQ(inName,"classdata") ) { return hx::Val( classdata); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"residueBooks") ) { return hx::Val( residueBooks); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"classifications") ) { return hx::Val( classifications); }
	}
	return super::__Field(inName,inCallProp);
}

bool Residue_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
	}
	return false;
}

hx::Val Residue_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { end=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"begin") ) { begin=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"partSize") ) { partSize=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"classbook") ) { classbook=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"classdata") ) { classdata=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"residueBooks") ) { residueBooks=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"classifications") ) { classifications=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Residue_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("begin","\x29","\xea","\x55","\xb0"));
	outFields->push(HX_HCSTRING("end","\xdb","\x03","\x4d","\x00"));
	outFields->push(HX_HCSTRING("partSize","\x54","\x26","\x0b","\x5e"));
	outFields->push(HX_HCSTRING("classifications","\x8d","\xf6","\x53","\xe7"));
	outFields->push(HX_HCSTRING("classbook","\x61","\x78","\x80","\xe9"));
	outFields->push(HX_HCSTRING("classdata","\x62","\x4a","\xc8","\xea"));
	outFields->push(HX_HCSTRING("residueBooks","\xdf","\xe7","\xab","\x0a"));
	outFields->push(HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Residue_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Residue_obj,begin),HX_HCSTRING("begin","\x29","\xea","\x55","\xb0")},
	{hx::fsInt,(int)offsetof(Residue_obj,end),HX_HCSTRING("end","\xdb","\x03","\x4d","\x00")},
	{hx::fsInt,(int)offsetof(Residue_obj,partSize),HX_HCSTRING("partSize","\x54","\x26","\x0b","\x5e")},
	{hx::fsInt,(int)offsetof(Residue_obj,classifications),HX_HCSTRING("classifications","\x8d","\xf6","\x53","\xe7")},
	{hx::fsInt,(int)offsetof(Residue_obj,classbook),HX_HCSTRING("classbook","\x61","\x78","\x80","\xe9")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Residue_obj,classdata),HX_HCSTRING("classdata","\x62","\x4a","\xc8","\xea")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Residue_obj,residueBooks),HX_HCSTRING("residueBooks","\xdf","\xe7","\xab","\x0a")},
	{hx::fsInt,(int)offsetof(Residue_obj,type),HX_HCSTRING("type","\xba","\xf2","\x08","\x4d")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Residue_obj_sStaticStorageInfo = 0;
#endif

static ::String Residue_obj_sMemberFields[] = {
	HX_HCSTRING("begin","\x29","\xea","\x55","\xb0"),
	HX_HCSTRING("end","\xdb","\x03","\x4d","\x00"),
	HX_HCSTRING("partSize","\x54","\x26","\x0b","\x5e"),
	HX_HCSTRING("classifications","\x8d","\xf6","\x53","\xe7"),
	HX_HCSTRING("classbook","\x61","\x78","\x80","\xe9"),
	HX_HCSTRING("classdata","\x62","\x4a","\xc8","\xea"),
	HX_HCSTRING("residueBooks","\xdf","\xe7","\xab","\x0a"),
	HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"),
	HX_HCSTRING("decode","\x2e","\x5d","\xed","\x64"),
	::String(null()) };

static void Residue_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Residue_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Residue_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Residue_obj::__mClass,"__mClass");
};

#endif

hx::Class Residue_obj::__mClass;

static ::String Residue_obj_sStaticFields[] = {
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null())
};

void Residue_obj::__register()
{
	hx::Object *dummy = new Residue_obj;
	Residue_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("stb.format.vorbis.data.Residue","\xd8","\xc5","\x5d","\x30");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Residue_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Residue_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Residue_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Residue_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Residue_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Residue_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Residue_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Residue_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace stb
} // end namespace format
} // end namespace vorbis
} // end namespace data
