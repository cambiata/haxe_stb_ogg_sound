// Generated by Haxe 3.4.0 (git build development @ 75c0f05)
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_BytesInput
#include <haxe/io/BytesInput.h>
#endif
#ifndef INCLUDED_haxe_io_BytesOutput
#include <haxe/io/BytesOutput.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <haxe/io/Output.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_VorbisDecodeState
#include <stb/format/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Codebook
#include <stb/format/vorbis/data/Codebook.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Comment
#include <stb/format/vorbis/data/Comment.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Floor
#include <stb/format/vorbis/data/Floor.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Header
#include <stb/format/vorbis/data/Header.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Mapping
#include <stb/format/vorbis/data/Mapping.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Mode
#include <stb/format/vorbis/data/Mode.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Page
#include <stb/format/vorbis/data/Page.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderError
#include <stb/format/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderErrorType
#include <stb/format/vorbis/data/ReaderErrorType.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Residue
#include <stb/format/vorbis/data/Residue.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d4550658b1516b0f_37_new,"stb.format.vorbis.data.Header","new",0x9d521d92,"stb.format.vorbis.data.Header.new","stb/format/vorbis/data/Header.hx",37,0x2900eb9e)
HX_DEFINE_STACK_FRAME(_hx_pos_d4550658b1516b0f_41_read,"stb.format.vorbis.data.Header","read",0x0d2c89e4,"stb.format.vorbis.data.Header.read","stb/format/vorbis/data/Header.hx",41,0x2900eb9e)
HX_DEFINE_STACK_FRAME(_hx_pos_d4550658b1516b0f_18_boot,"stb.format.vorbis.data.Header","boot",0x02a0c2c0,"stb.format.vorbis.data.Header.boot","stb/format/vorbis/data/Header.hx",18,0x2900eb9e)
HX_DEFINE_STACK_FRAME(_hx_pos_d4550658b1516b0f_19_boot,"stb.format.vorbis.data.Header","boot",0x02a0c2c0,"stb.format.vorbis.data.Header.boot","stb/format/vorbis/data/Header.hx",19,0x2900eb9e)
HX_DEFINE_STACK_FRAME(_hx_pos_d4550658b1516b0f_20_boot,"stb.format.vorbis.data.Header","boot",0x02a0c2c0,"stb.format.vorbis.data.Header.boot","stb/format/vorbis/data/Header.hx",20,0x2900eb9e)
namespace stb{
namespace format{
namespace vorbis{
namespace data{

void Header_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d4550658b1516b0f_37_new)
            	HX_STACK_THIS(this)
            	}

Dynamic Header_obj::__CreateEmpty() { return new Header_obj; }

void *Header_obj::_hx_vtable = 0;

Dynamic Header_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Header_obj > _hx_result = new Header_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Header_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x09b4ba42;
}

int Header_obj::PACKET_ID;

int Header_obj::PACKET_COMMENT;

int Header_obj::PACKET_SETUP;

 ::stb::format::vorbis::data::Header Header_obj::read( ::stb::format::vorbis::VorbisDecodeState decodeState){
            	HX_GC_STACKFRAME(&_hx_pos_d4550658b1516b0f_41_read)
            	HX_STACK_ARG(decodeState,"decodeState")
HXLINE(  42)		HX_VARI(  ::stb::format::vorbis::data::Page,page) = decodeState->page;
HXLINE(  43)		page->start(decodeState);
HXLINE(  45)		if ((((int)page->flag & (int)(int)2) == (int)0)) {
HXLINE(  46)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("not firstPage",52,61,ee,e9),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),46,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  48)		if ((((int)page->flag & (int)(int)4) != (int)0)) {
HXLINE(  49)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("lastPage",c5,f3,9a,dd),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),49,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  51)		if ((((int)page->flag & (int)(int)1) != (int)0)) {
HXLINE(  52)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("continuedPacket",85,39,ee,94),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),52,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  55)		decodeState->firstPageValidate();
HXLINE(  56)		decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  56)		if ((decodeState->input->readByte() != (int)1)) {
HXLINE(  57)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("decodeState head",5d,8c,63,29),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),57,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  61)		{
HXLINE(  61)			HX_VARI(  ::haxe::io::Bytes,header) = ::haxe::io::Bytes_obj::alloc((int)6);
HXDLIN(  61)			{
HXLINE(  61)				HX_VARI( int,_g) = (int)0;
HXDLIN(  61)				while((_g < (int)6)){
HXLINE(  61)					_g = (_g + (int)1);
HXDLIN(  61)					{
HXLINE(  61)						HX_VAR( int,x);
HXDLIN(  61)						bool x1;
HXDLIN(  61)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  61)							if (!(decodeState->lastSeg)) {
HXLINE(  61)								x1 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE(  61)								x1 = true;
            							}
            						}
            						else {
HXLINE(  61)							x1 = false;
            						}
HXDLIN(  61)						if (x1) {
HXLINE(  61)							x = (int)-1;
            						}
            						else {
HXLINE(  61)							decodeState->bytesInSeg--;
HXDLIN(  61)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  61)							x = decodeState->input->readByte();
            						}
HXDLIN(  61)						decodeState->validBits = (int)0;
HXDLIN(  61)						header->b[(_g - (int)1)] = x;
            					}
            				}
            			}
HXDLIN(  61)			if ((header->toString() != HX_("vorbis",53,03,3c,63))) {
HXLINE(  61)				HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("vorbis header",ba,3e,a4,0e),hx::SourceInfo(HX_("VorbisDecodeState.hx",6e,33,f8,9f),300,HX_("stb.format.vorbis.VorbisDecodeState",bf,03,cb,a1),HX_("vorbisValidate",09,9b,51,16))));
            			}
            		}
HXLINE(  64)		decodeState->inputPosition = (decodeState->inputPosition + (int)4);
HXDLIN(  64)		HX_VARI( int,version) = decodeState->input->readInt32();
HXLINE(  65)		if ((version != (int)0)) {
HXLINE(  66)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),(HX_("vorbis version : ",5b,e2,58,09) + version),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),66,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  69)		HX_VARI_NAME(  ::stb::format::vorbis::data::Header,header1,"header") =  ::stb::format::vorbis::data::Header_obj::__alloc( HX_CTX );
HXLINE(  71)		decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  71)		header1->channel = decodeState->input->readByte();
HXLINE(  72)		if ((header1->channel == (int)0)) {
HXLINE(  73)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("no channel",e4,4d,cc,09),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),73,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
            		else {
HXLINE(  74)			if ((header1->channel > (int)16)) {
HXLINE(  75)				HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::TOO_MANY_CHANNELS_dyn(),HX_("too many channels",65,2f,80,4b),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),75,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            			}
            		}
HXLINE(  78)		decodeState->inputPosition = (decodeState->inputPosition + (int)4);
HXDLIN(  78)		header1->sampleRate = decodeState->input->readInt32();
HXLINE(  79)		if ((header1->sampleRate == (int)0)) {
HXLINE(  80)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("no sampling rate",9a,91,ba,fc),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),80,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  83)		decodeState->inputPosition = (decodeState->inputPosition + (int)4);
HXDLIN(  83)		header1->maximumBitRate = decodeState->input->readInt32();
HXLINE(  84)		decodeState->inputPosition = (decodeState->inputPosition + (int)4);
HXDLIN(  84)		header1->nominalBitRate = decodeState->input->readInt32();
HXLINE(  85)		decodeState->inputPosition = (decodeState->inputPosition + (int)4);
HXDLIN(  85)		header1->minimumBitRate = decodeState->input->readInt32();
HXLINE(  87)		decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  87)		HX_VARI_NAME( int,x2,"x") = decodeState->input->readByte();
HXLINE(  88)		HX_VARI( int,log0) = ((int)x2 & (int)(int)15);
HXLINE(  89)		HX_VARI( int,log1) = ((int)x2 >> (int)(int)4);
HXLINE(  90)		header1->blocksize0 = ((int)(int)1 << (int)log0);
HXLINE(  91)		header1->blocksize1 = ((int)(int)1 << (int)log1);
HXLINE(  92)		bool _hx_tmp;
HXDLIN(  92)		if ((log0 >= (int)6)) {
HXLINE(  92)			_hx_tmp = (log0 > (int)13);
            		}
            		else {
HXLINE(  92)			_hx_tmp = true;
            		}
HXDLIN(  92)		if (_hx_tmp) {
HXLINE(  93)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),93,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  95)		bool _hx_tmp1;
HXDLIN(  95)		if ((log1 >= (int)6)) {
HXLINE(  95)			_hx_tmp1 = (log1 > (int)13);
            		}
            		else {
HXLINE(  95)			_hx_tmp1 = true;
            		}
HXDLIN(  95)		if (_hx_tmp1) {
HXLINE(  96)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),96,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  98)		if ((log0 > log1)) {
HXLINE(  99)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),99,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE( 103)		decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 103)		HX_VARI_NAME( int,x3,"x") = decodeState->input->readByte();
HXLINE( 104)		if ((((int)x3 & (int)(int)1) == (int)0)) {
HXLINE( 105)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),105,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE( 109)		decodeState->page->start(decodeState);
HXLINE( 110)		decodeState->startPacket();
HXLINE( 112)		HX_VARI( int,len) = (int)0;
HXLINE( 113)		HX_VARI(  ::haxe::io::BytesOutput,output) =  ::haxe::io::BytesOutput_obj::__alloc( HX_CTX );
HXLINE( 114)		while(true){
HXLINE( 114)			len = decodeState->next();
HXDLIN( 114)			if (!((len != (int)0))) {
HXLINE( 114)				goto _hx_goto_2;
            			}
HXLINE( 115)			decodeState->inputPosition = (decodeState->inputPosition + len);
HXDLIN( 115)			output->write(decodeState->input->read(len));
HXLINE( 116)			decodeState->bytesInSeg = (int)0;
            		}
            		_hx_goto_2:;
HXLINE( 119)		{
HXLINE( 120)			HX_VARI(  ::haxe::io::BytesInput,packetInput) =  ::haxe::io::BytesInput_obj::__alloc( HX_CTX ,output->getBytes(),null(),null());
HXLINE( 121)			packetInput->readByte();
HXLINE( 122)			packetInput->read((int)6);
HXLINE( 125)			header1->vendor = packetInput->readString(packetInput->readInt32());
HXLINE( 126)			header1->comment =  ::stb::format::vorbis::data::Comment_obj::__alloc( HX_CTX );
HXLINE( 128)			HX_VARI( int,commentCount) = packetInput->readInt32();
HXLINE( 130)			{
HXLINE( 130)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 130)				while((_g1 < commentCount)){
HXLINE( 130)					_g1 = (_g1 + (int)1);
HXLINE( 132)					HX_VARI( ::String,str) = packetInput->readString(packetInput->readInt32());
HXLINE( 133)					HX_VARI( int,splitter) = str.indexOf(HX_("=",3d,00,00,00),null());
HXLINE( 134)					if ((splitter != (int)-1)) {
HXLINE( 135)						HX_VARI_NAME(  ::stb::format::vorbis::data::Comment,header2,"header") = header1->comment;
HXDLIN( 135)						::String _hx_tmp2 = str.substring((int)0,splitter);
HXDLIN( 135)						header2->add(_hx_tmp2,str.substring((splitter + (int)1),null()));
            					}
            				}
            			}
HXLINE( 140)			if ((((int)packetInput->readByte() & (int)(int)1) == (int)0)) {
HXLINE( 141)				HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),141,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            			}
            		}
HXLINE( 146)		decodeState->startPacket();
HXLINE( 148)		HX_VAR_NAME( int,x4,"x");
HXDLIN( 148)		bool x5;
HXDLIN( 148)		if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 148)			if (!(decodeState->lastSeg)) {
HXLINE( 148)				x5 = (decodeState->next() == (int)0);
            			}
            			else {
HXLINE( 148)				x5 = true;
            			}
            		}
            		else {
HXLINE( 148)			x5 = false;
            		}
HXDLIN( 148)		if (x5) {
HXLINE( 148)			x4 = (int)-1;
            		}
            		else {
HXLINE( 148)			decodeState->bytesInSeg--;
HXDLIN( 148)			decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 148)			x4 = decodeState->input->readByte();
            		}
HXDLIN( 148)		decodeState->validBits = (int)0;
HXDLIN( 148)		if ((x4 != (int)5)) {
HXLINE( 149)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("setup packet",cb,fa,2a,07),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),149,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            		}
HXLINE( 152)		{
HXLINE( 152)			HX_VARI_NAME(  ::haxe::io::Bytes,header3,"header") = ::haxe::io::Bytes_obj::alloc((int)6);
HXDLIN( 152)			{
HXLINE( 152)				HX_VARI_NAME( int,_g2,"_g") = (int)0;
HXDLIN( 152)				while((_g2 < (int)6)){
HXLINE( 152)					_g2 = (_g2 + (int)1);
HXDLIN( 152)					{
HXLINE( 152)						HX_VAR_NAME( int,x6,"x");
HXDLIN( 152)						bool x7;
HXDLIN( 152)						if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 152)							if (!(decodeState->lastSeg)) {
HXLINE( 152)								x7 = (decodeState->next() == (int)0);
            							}
            							else {
HXLINE( 152)								x7 = true;
            							}
            						}
            						else {
HXLINE( 152)							x7 = false;
            						}
HXDLIN( 152)						if (x7) {
HXLINE( 152)							x6 = (int)-1;
            						}
            						else {
HXLINE( 152)							decodeState->bytesInSeg--;
HXDLIN( 152)							decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 152)							x6 = decodeState->input->readByte();
            						}
HXDLIN( 152)						decodeState->validBits = (int)0;
HXDLIN( 152)						header3->b[(_g2 - (int)1)] = x6;
            					}
            				}
            			}
HXDLIN( 152)			if ((header3->toString() != HX_("vorbis",53,03,3c,63))) {
HXLINE( 152)				HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("vorbis header",ba,3e,a4,0e),hx::SourceInfo(HX_("VorbisDecodeState.hx",6e,33,f8,9f),300,HX_("stb.format.vorbis.VorbisDecodeState",bf,03,cb,a1),HX_("vorbisValidate",09,9b,51,16))));
            			}
            		}
HXLINE( 155)		int codebookCount;
HXDLIN( 155)		if ((decodeState->validBits < (int)0)) {
HXLINE( 155)			codebookCount = (int)0;
            		}
            		else {
HXLINE( 155)			if ((decodeState->validBits < (int)8)) {
HXLINE( 155)				if ((decodeState->validBits == (int)0)) {
HXLINE( 155)					decodeState->acc = (int)0;
            				}
HXDLIN( 155)				while(true){
HXLINE( 155)					bool codebookCount1;
HXDLIN( 155)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 155)						if (!(decodeState->lastSeg)) {
HXLINE( 155)							codebookCount1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 155)							codebookCount1 = true;
            						}
            					}
            					else {
HXLINE( 155)						codebookCount1 = false;
            					}
HXDLIN( 155)					if (codebookCount1) {
HXLINE( 155)						decodeState->validBits = (int)-1;
HXDLIN( 155)						goto _hx_goto_5;
            					}
            					else {
HXLINE( 155)						decodeState->bytesInSeg--;
HXDLIN( 155)						int a = decodeState->acc;
HXDLIN( 155)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 155)						int b = decodeState->input->readByte();
HXDLIN( 155)						decodeState->acc = (a + ((int)b << (int)decodeState->validBits));
HXDLIN( 155)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 155)					if (!((decodeState->validBits < (int)8))) {
HXLINE( 155)						goto _hx_goto_5;
            					}
            				}
            				_hx_goto_5:;
HXDLIN( 155)				if ((decodeState->validBits < (int)0)) {
HXLINE( 155)					codebookCount = (int)0;
            				}
            				else {
HXLINE( 155)					HX_VARI( int,z) = ((int)decodeState->acc & (int)(int)255);
HXDLIN( 155)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN( 155)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN( 155)					codebookCount = z;
            				}
            			}
            			else {
HXLINE( 155)				HX_VARI_NAME( int,z1,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN( 155)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN( 155)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN( 155)				codebookCount = z1;
            			}
            		}
HXDLIN( 155)		HX_VARI_NAME( int,codebookCount2,"codebookCount") = (codebookCount + (int)1);
HXLINE( 156)		header1->codebooks = ::Array_obj< ::Dynamic>::__new(codebookCount2);
HXLINE( 157)		{
HXLINE( 157)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 157)			while((_g11 < codebookCount2)){
HXLINE( 157)				_g11 = (_g11 + (int)1);
HXLINE( 158)				{
HXLINE( 158)					::Array< ::Dynamic> this1 = header1->codebooks;
HXDLIN( 158)					 ::stb::format::vorbis::data::Codebook val = ::stb::format::vorbis::data::Codebook_obj::read(decodeState);
HXDLIN( 158)					this1->__unsafe_set((_g11 - (int)1),val);
            				}
            			}
            		}
HXLINE( 162)		int x8;
HXDLIN( 162)		if ((decodeState->validBits < (int)0)) {
HXLINE( 162)			x8 = (int)0;
            		}
            		else {
HXLINE( 162)			if ((decodeState->validBits < (int)6)) {
HXLINE( 162)				if ((decodeState->validBits == (int)0)) {
HXLINE( 162)					decodeState->acc = (int)0;
            				}
HXDLIN( 162)				while(true){
HXLINE( 162)					bool x9;
HXDLIN( 162)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 162)						if (!(decodeState->lastSeg)) {
HXLINE( 162)							x9 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 162)							x9 = true;
            						}
            					}
            					else {
HXLINE( 162)						x9 = false;
            					}
HXDLIN( 162)					if (x9) {
HXLINE( 162)						decodeState->validBits = (int)-1;
HXDLIN( 162)						goto _hx_goto_7;
            					}
            					else {
HXLINE( 162)						decodeState->bytesInSeg--;
HXDLIN( 162)						int a1 = decodeState->acc;
HXDLIN( 162)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 162)						int b1 = decodeState->input->readByte();
HXDLIN( 162)						decodeState->acc = (a1 + ((int)b1 << (int)decodeState->validBits));
HXDLIN( 162)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 162)					if (!((decodeState->validBits < (int)6))) {
HXLINE( 162)						goto _hx_goto_7;
            					}
            				}
            				_hx_goto_7:;
HXDLIN( 162)				if ((decodeState->validBits < (int)0)) {
HXLINE( 162)					x8 = (int)0;
            				}
            				else {
HXLINE( 162)					HX_VARI_NAME( int,z2,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 162)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 162)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 162)					x8 = z2;
            				}
            			}
            			else {
HXLINE( 162)				HX_VARI_NAME( int,z3,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 162)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 162)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 162)				x8 = z3;
            			}
            		}
HXDLIN( 162)		x3 = (x8 + (int)1);
HXLINE( 163)		{
HXLINE( 163)			HX_VARI_NAME( int,_g12,"_g1") = (int)0;
HXDLIN( 163)			HX_VARI_NAME( int,_g3,"_g") = x3;
HXDLIN( 163)			while((_g12 < _g3)){
HXLINE( 163)				_g12 = (_g12 + (int)1);
HXLINE( 164)				int _hx_tmp3;
HXDLIN( 164)				if ((decodeState->validBits < (int)0)) {
HXLINE( 164)					_hx_tmp3 = (int)0;
            				}
            				else {
HXLINE( 164)					if ((decodeState->validBits < (int)16)) {
HXLINE( 164)						if ((decodeState->validBits == (int)0)) {
HXLINE( 164)							decodeState->acc = (int)0;
            						}
HXDLIN( 164)						while(true){
HXLINE( 164)							bool _hx_tmp4;
HXDLIN( 164)							if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 164)								if (!(decodeState->lastSeg)) {
HXLINE( 164)									_hx_tmp4 = (decodeState->next() == (int)0);
            								}
            								else {
HXLINE( 164)									_hx_tmp4 = true;
            								}
            							}
            							else {
HXLINE( 164)								_hx_tmp4 = false;
            							}
HXDLIN( 164)							if (_hx_tmp4) {
HXLINE( 164)								decodeState->validBits = (int)-1;
HXDLIN( 164)								goto _hx_goto_9;
            							}
            							else {
HXLINE( 164)								decodeState->bytesInSeg--;
HXDLIN( 164)								int a2 = decodeState->acc;
HXDLIN( 164)								decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 164)								int b2 = decodeState->input->readByte();
HXDLIN( 164)								decodeState->acc = (a2 + ((int)b2 << (int)decodeState->validBits));
HXDLIN( 164)								decodeState->validBits = (decodeState->validBits + (int)8);
            							}
HXDLIN( 164)							if (!((decodeState->validBits < (int)16))) {
HXLINE( 164)								goto _hx_goto_9;
            							}
            						}
            						_hx_goto_9:;
HXDLIN( 164)						if ((decodeState->validBits < (int)0)) {
HXLINE( 164)							_hx_tmp3 = (int)0;
            						}
            						else {
HXLINE( 164)							HX_VARI_NAME( int,z4,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN( 164)							decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN( 164)							decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN( 164)							_hx_tmp3 = z4;
            						}
            					}
            					else {
HXLINE( 164)						HX_VARI_NAME( int,z5,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN( 164)						decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN( 164)						decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN( 164)						_hx_tmp3 = z5;
            					}
            				}
HXDLIN( 164)				if ((_hx_tmp3 != (int)0)) {
HXLINE( 165)					HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),165,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            				}
            			}
            		}
HXLINE( 170)		int floorCount;
HXDLIN( 170)		if ((decodeState->validBits < (int)0)) {
HXLINE( 170)			floorCount = (int)0;
            		}
            		else {
HXLINE( 170)			if ((decodeState->validBits < (int)6)) {
HXLINE( 170)				if ((decodeState->validBits == (int)0)) {
HXLINE( 170)					decodeState->acc = (int)0;
            				}
HXDLIN( 170)				while(true){
HXLINE( 170)					bool floorCount1;
HXDLIN( 170)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 170)						if (!(decodeState->lastSeg)) {
HXLINE( 170)							floorCount1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 170)							floorCount1 = true;
            						}
            					}
            					else {
HXLINE( 170)						floorCount1 = false;
            					}
HXDLIN( 170)					if (floorCount1) {
HXLINE( 170)						decodeState->validBits = (int)-1;
HXDLIN( 170)						goto _hx_goto_10;
            					}
            					else {
HXLINE( 170)						decodeState->bytesInSeg--;
HXDLIN( 170)						int a3 = decodeState->acc;
HXDLIN( 170)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 170)						int b3 = decodeState->input->readByte();
HXDLIN( 170)						decodeState->acc = (a3 + ((int)b3 << (int)decodeState->validBits));
HXDLIN( 170)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 170)					if (!((decodeState->validBits < (int)6))) {
HXLINE( 170)						goto _hx_goto_10;
            					}
            				}
            				_hx_goto_10:;
HXDLIN( 170)				if ((decodeState->validBits < (int)0)) {
HXLINE( 170)					floorCount = (int)0;
            				}
            				else {
HXLINE( 170)					HX_VARI_NAME( int,z6,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 170)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 170)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 170)					floorCount = z6;
            				}
            			}
            			else {
HXLINE( 170)				HX_VARI_NAME( int,z7,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 170)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 170)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 170)				floorCount = z7;
            			}
            		}
HXDLIN( 170)		HX_VARI_NAME( int,floorCount2,"floorCount") = (floorCount + (int)1);
HXLINE( 171)		header1->floorConfig = ::Array_obj< ::Dynamic>::__new(floorCount2);
HXLINE( 172)		{
HXLINE( 172)			HX_VARI_NAME( int,_g13,"_g1") = (int)0;
HXDLIN( 172)			while((_g13 < floorCount2)){
HXLINE( 172)				_g13 = (_g13 + (int)1);
HXLINE( 173)				{
HXLINE( 173)					::Array< ::Dynamic> this2 = header1->floorConfig;
HXDLIN( 173)					 ::stb::format::vorbis::data::Floor val1 = ::stb::format::vorbis::data::Floor_obj::read(decodeState,header1->codebooks);
HXDLIN( 173)					this2->__unsafe_set((_g13 - (int)1),val1);
            				}
            			}
            		}
HXLINE( 177)		int residueCount;
HXDLIN( 177)		if ((decodeState->validBits < (int)0)) {
HXLINE( 177)			residueCount = (int)0;
            		}
            		else {
HXLINE( 177)			if ((decodeState->validBits < (int)6)) {
HXLINE( 177)				if ((decodeState->validBits == (int)0)) {
HXLINE( 177)					decodeState->acc = (int)0;
            				}
HXDLIN( 177)				while(true){
HXLINE( 177)					bool residueCount1;
HXDLIN( 177)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 177)						if (!(decodeState->lastSeg)) {
HXLINE( 177)							residueCount1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 177)							residueCount1 = true;
            						}
            					}
            					else {
HXLINE( 177)						residueCount1 = false;
            					}
HXDLIN( 177)					if (residueCount1) {
HXLINE( 177)						decodeState->validBits = (int)-1;
HXDLIN( 177)						goto _hx_goto_12;
            					}
            					else {
HXLINE( 177)						decodeState->bytesInSeg--;
HXDLIN( 177)						int a4 = decodeState->acc;
HXDLIN( 177)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 177)						int b4 = decodeState->input->readByte();
HXDLIN( 177)						decodeState->acc = (a4 + ((int)b4 << (int)decodeState->validBits));
HXDLIN( 177)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 177)					if (!((decodeState->validBits < (int)6))) {
HXLINE( 177)						goto _hx_goto_12;
            					}
            				}
            				_hx_goto_12:;
HXDLIN( 177)				if ((decodeState->validBits < (int)0)) {
HXLINE( 177)					residueCount = (int)0;
            				}
            				else {
HXLINE( 177)					HX_VARI_NAME( int,z8,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 177)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 177)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 177)					residueCount = z8;
            				}
            			}
            			else {
HXLINE( 177)				HX_VARI_NAME( int,z9,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 177)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 177)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 177)				residueCount = z9;
            			}
            		}
HXDLIN( 177)		HX_VARI_NAME( int,residueCount2,"residueCount") = (residueCount + (int)1);
HXLINE( 178)		header1->residueConfig = ::Array_obj< ::Dynamic>::__new(residueCount2);
HXLINE( 179)		{
HXLINE( 179)			HX_VARI_NAME( int,_g14,"_g1") = (int)0;
HXDLIN( 179)			while((_g14 < residueCount2)){
HXLINE( 179)				_g14 = (_g14 + (int)1);
HXLINE( 180)				{
HXLINE( 180)					::Array< ::Dynamic> this3 = header1->residueConfig;
HXDLIN( 180)					 ::stb::format::vorbis::data::Residue val2 = ::stb::format::vorbis::data::Residue_obj::read(decodeState,header1->codebooks);
HXDLIN( 180)					this3->__unsafe_set((_g14 - (int)1),val2);
            				}
            			}
            		}
HXLINE( 184)		int mappingCount;
HXDLIN( 184)		if ((decodeState->validBits < (int)0)) {
HXLINE( 184)			mappingCount = (int)0;
            		}
            		else {
HXLINE( 184)			if ((decodeState->validBits < (int)6)) {
HXLINE( 184)				if ((decodeState->validBits == (int)0)) {
HXLINE( 184)					decodeState->acc = (int)0;
            				}
HXDLIN( 184)				while(true){
HXLINE( 184)					bool mappingCount1;
HXDLIN( 184)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 184)						if (!(decodeState->lastSeg)) {
HXLINE( 184)							mappingCount1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 184)							mappingCount1 = true;
            						}
            					}
            					else {
HXLINE( 184)						mappingCount1 = false;
            					}
HXDLIN( 184)					if (mappingCount1) {
HXLINE( 184)						decodeState->validBits = (int)-1;
HXDLIN( 184)						goto _hx_goto_14;
            					}
            					else {
HXLINE( 184)						decodeState->bytesInSeg--;
HXDLIN( 184)						int a5 = decodeState->acc;
HXDLIN( 184)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 184)						int b5 = decodeState->input->readByte();
HXDLIN( 184)						decodeState->acc = (a5 + ((int)b5 << (int)decodeState->validBits));
HXDLIN( 184)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 184)					if (!((decodeState->validBits < (int)6))) {
HXLINE( 184)						goto _hx_goto_14;
            					}
            				}
            				_hx_goto_14:;
HXDLIN( 184)				if ((decodeState->validBits < (int)0)) {
HXLINE( 184)					mappingCount = (int)0;
            				}
            				else {
HXLINE( 184)					HX_VARI_NAME( int,z10,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 184)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 184)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 184)					mappingCount = z10;
            				}
            			}
            			else {
HXLINE( 184)				HX_VARI_NAME( int,z11,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 184)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 184)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 184)				mappingCount = z11;
            			}
            		}
HXDLIN( 184)		HX_VARI_NAME( int,mappingCount2,"mappingCount") = (mappingCount + (int)1);
HXLINE( 185)		header1->mapping = ::Array_obj< ::Dynamic>::__new(mappingCount2);
HXLINE( 186)		{
HXLINE( 186)			HX_VARI_NAME( int,_g15,"_g1") = (int)0;
HXDLIN( 186)			while((_g15 < mappingCount2)){
HXLINE( 186)				_g15 = (_g15 + (int)1);
HXLINE( 187)				HX_VARI(  ::stb::format::vorbis::data::Mapping,map) = ::stb::format::vorbis::data::Mapping_obj::read(decodeState,header1->channel);
HXLINE( 188)				header1->mapping->__unsafe_set((_g15 - (int)1),map);
HXLINE( 189)				{
HXLINE( 189)					HX_VARI_NAME( int,_g31,"_g3") = (int)0;
HXDLIN( 189)					HX_VARI_NAME( int,_g21,"_g2") = map->submaps;
HXDLIN( 189)					while((_g31 < _g21)){
HXLINE( 189)						_g31 = (_g31 + (int)1);
HXDLIN( 189)						HX_VARI( int,j) = (_g31 - (int)1);
HXLINE( 190)						int _hx_tmp5 = ( (int)(_hx_array_unsafe_get(map->submapFloor,j)) );
HXDLIN( 190)						if ((_hx_tmp5 >= header1->floorConfig->length)) {
HXLINE( 191)							HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),191,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            						}
HXLINE( 193)						int _hx_tmp6 = ( (int)(_hx_array_unsafe_get(map->submapResidue,j)) );
HXDLIN( 193)						if ((_hx_tmp6 >= header1->residueConfig->length)) {
HXLINE( 194)							HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),194,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            						}
            					}
            				}
            			}
            		}
HXLINE( 199)		int modeCount;
HXDLIN( 199)		if ((decodeState->validBits < (int)0)) {
HXLINE( 199)			modeCount = (int)0;
            		}
            		else {
HXLINE( 199)			if ((decodeState->validBits < (int)6)) {
HXLINE( 199)				if ((decodeState->validBits == (int)0)) {
HXLINE( 199)					decodeState->acc = (int)0;
            				}
HXDLIN( 199)				while(true){
HXLINE( 199)					bool modeCount1;
HXDLIN( 199)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 199)						if (!(decodeState->lastSeg)) {
HXLINE( 199)							modeCount1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE( 199)							modeCount1 = true;
            						}
            					}
            					else {
HXLINE( 199)						modeCount1 = false;
            					}
HXDLIN( 199)					if (modeCount1) {
HXLINE( 199)						decodeState->validBits = (int)-1;
HXDLIN( 199)						goto _hx_goto_17;
            					}
            					else {
HXLINE( 199)						decodeState->bytesInSeg--;
HXDLIN( 199)						int a6 = decodeState->acc;
HXDLIN( 199)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 199)						int b6 = decodeState->input->readByte();
HXDLIN( 199)						decodeState->acc = (a6 + ((int)b6 << (int)decodeState->validBits));
HXDLIN( 199)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN( 199)					if (!((decodeState->validBits < (int)6))) {
HXLINE( 199)						goto _hx_goto_17;
            					}
            				}
            				_hx_goto_17:;
HXDLIN( 199)				if ((decodeState->validBits < (int)0)) {
HXLINE( 199)					modeCount = (int)0;
            				}
            				else {
HXLINE( 199)					HX_VARI_NAME( int,z12,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 199)					decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 199)					decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 199)					modeCount = z12;
            				}
            			}
            			else {
HXLINE( 199)				HX_VARI_NAME( int,z13,"z") = ((int)decodeState->acc & (int)(int)63);
HXDLIN( 199)				decodeState->acc = hx::UShr(decodeState->acc,(int)6);
HXDLIN( 199)				decodeState->validBits = (decodeState->validBits - (int)6);
HXDLIN( 199)				modeCount = z13;
            			}
            		}
HXDLIN( 199)		HX_VARI_NAME( int,modeCount2,"modeCount") = (modeCount + (int)1);
HXLINE( 200)		header1->modes = ::Array_obj< ::Dynamic>::__new(modeCount2);
HXLINE( 201)		{
HXLINE( 201)			HX_VARI_NAME( int,_g16,"_g1") = (int)0;
HXDLIN( 201)			while((_g16 < modeCount2)){
HXLINE( 201)				_g16 = (_g16 + (int)1);
HXLINE( 202)				HX_VARI(  ::stb::format::vorbis::data::Mode,mode) = ::stb::format::vorbis::data::Mode_obj::read(decodeState);
HXLINE( 203)				header1->modes->__unsafe_set((_g16 - (int)1),mode);
HXLINE( 204)				if ((mode->mapping >= header1->mapping->length)) {
HXLINE( 205)					HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Header.hx",31,cf,14,15),205,HX_("stb.format.vorbis.data.Header",a0,ac,33,5d),HX_("read",56,4b,a7,4b))));
            				}
            			}
            		}
HXLINE( 209)		while(true){
HXLINE( 209)			bool _hx_tmp7;
HXDLIN( 209)			if ((decodeState->bytesInSeg == (int)0)) {
HXLINE( 209)				if (!(decodeState->lastSeg)) {
HXLINE( 209)					_hx_tmp7 = (decodeState->next() != (int)0);
            				}
            				else {
HXLINE( 209)					_hx_tmp7 = false;
            				}
            			}
            			else {
HXLINE( 209)				_hx_tmp7 = true;
            			}
HXDLIN( 209)			if (!(_hx_tmp7)) {
HXLINE( 209)				goto _hx_goto_19;
            			}
HXDLIN( 209)			decodeState->bytesInSeg--;
HXDLIN( 209)			{
HXLINE( 209)				decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN( 209)				decodeState->input->readByte();
            			}
            		}
            		_hx_goto_19:;
HXLINE( 211)		return header1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Header_obj,read,return )


Header_obj::Header_obj()
{
}

void Header_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Header);
	HX_MARK_MEMBER_NAME(maximumBitRate,"maximumBitRate");
	HX_MARK_MEMBER_NAME(nominalBitRate,"nominalBitRate");
	HX_MARK_MEMBER_NAME(minimumBitRate,"minimumBitRate");
	HX_MARK_MEMBER_NAME(sampleRate,"sampleRate");
	HX_MARK_MEMBER_NAME(channel,"channel");
	HX_MARK_MEMBER_NAME(blocksize0,"blocksize0");
	HX_MARK_MEMBER_NAME(blocksize1,"blocksize1");
	HX_MARK_MEMBER_NAME(codebooks,"codebooks");
	HX_MARK_MEMBER_NAME(floorConfig,"floorConfig");
	HX_MARK_MEMBER_NAME(residueConfig,"residueConfig");
	HX_MARK_MEMBER_NAME(mapping,"mapping");
	HX_MARK_MEMBER_NAME(modes,"modes");
	HX_MARK_MEMBER_NAME(comment,"comment");
	HX_MARK_MEMBER_NAME(vendor,"vendor");
	HX_MARK_END_CLASS();
}

void Header_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(maximumBitRate,"maximumBitRate");
	HX_VISIT_MEMBER_NAME(nominalBitRate,"nominalBitRate");
	HX_VISIT_MEMBER_NAME(minimumBitRate,"minimumBitRate");
	HX_VISIT_MEMBER_NAME(sampleRate,"sampleRate");
	HX_VISIT_MEMBER_NAME(channel,"channel");
	HX_VISIT_MEMBER_NAME(blocksize0,"blocksize0");
	HX_VISIT_MEMBER_NAME(blocksize1,"blocksize1");
	HX_VISIT_MEMBER_NAME(codebooks,"codebooks");
	HX_VISIT_MEMBER_NAME(floorConfig,"floorConfig");
	HX_VISIT_MEMBER_NAME(residueConfig,"residueConfig");
	HX_VISIT_MEMBER_NAME(mapping,"mapping");
	HX_VISIT_MEMBER_NAME(modes,"modes");
	HX_VISIT_MEMBER_NAME(comment,"comment");
	HX_VISIT_MEMBER_NAME(vendor,"vendor");
}

hx::Val Header_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"modes") ) { return hx::Val( modes); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"vendor") ) { return hx::Val( vendor); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"channel") ) { return hx::Val( channel); }
		if (HX_FIELD_EQ(inName,"mapping") ) { return hx::Val( mapping); }
		if (HX_FIELD_EQ(inName,"comment") ) { return hx::Val( comment); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"codebooks") ) { return hx::Val( codebooks); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sampleRate") ) { return hx::Val( sampleRate); }
		if (HX_FIELD_EQ(inName,"blocksize0") ) { return hx::Val( blocksize0); }
		if (HX_FIELD_EQ(inName,"blocksize1") ) { return hx::Val( blocksize1); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"floorConfig") ) { return hx::Val( floorConfig); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"residueConfig") ) { return hx::Val( residueConfig); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"maximumBitRate") ) { return hx::Val( maximumBitRate); }
		if (HX_FIELD_EQ(inName,"nominalBitRate") ) { return hx::Val( nominalBitRate); }
		if (HX_FIELD_EQ(inName,"minimumBitRate") ) { return hx::Val( minimumBitRate); }
	}
	return super::__Field(inName,inCallProp);
}

bool Header_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
	}
	return false;
}

hx::Val Header_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"modes") ) { modes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"vendor") ) { vendor=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"channel") ) { channel=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mapping") ) { mapping=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"comment") ) { comment=inValue.Cast<  ::stb::format::vorbis::data::Comment >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"codebooks") ) { codebooks=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sampleRate") ) { sampleRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blocksize0") ) { blocksize0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blocksize1") ) { blocksize1=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"floorConfig") ) { floorConfig=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"residueConfig") ) { residueConfig=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"maximumBitRate") ) { maximumBitRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nominalBitRate") ) { nominalBitRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minimumBitRate") ) { minimumBitRate=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Header_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("maximumBitRate","\x4d","\x56","\x30","\x56"));
	outFields->push(HX_HCSTRING("nominalBitRate","\x91","\xa2","\x66","\x22"));
	outFields->push(HX_HCSTRING("minimumBitRate","\x1f","\xfa","\xb9","\xf2"));
	outFields->push(HX_HCSTRING("sampleRate","\x2a","\x3c","\x4c","\x67"));
	outFields->push(HX_HCSTRING("channel","\xc3","\x00","\xd2","\xcc"));
	outFields->push(HX_HCSTRING("blocksize0","\xe2","\x3b","\x0f","\xc1"));
	outFields->push(HX_HCSTRING("blocksize1","\xe3","\x3b","\x0f","\xc1"));
	outFields->push(HX_HCSTRING("codebooks","\xdd","\x0b","\xa1","\xb7"));
	outFields->push(HX_HCSTRING("floorConfig","\xae","\xfd","\x8a","\x3c"));
	outFields->push(HX_HCSTRING("residueConfig","\x6d","\x4d","\x6d","\xb1"));
	outFields->push(HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"));
	outFields->push(HX_HCSTRING("modes","\xb0","\x23","\x58","\x0c"));
	outFields->push(HX_HCSTRING("comment","\x5f","\x7a","\x70","\x81"));
	outFields->push(HX_HCSTRING("vendor","\x88","\xe5","\x96","\x9e"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Header_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Header_obj,maximumBitRate),HX_HCSTRING("maximumBitRate","\x4d","\x56","\x30","\x56")},
	{hx::fsInt,(int)offsetof(Header_obj,nominalBitRate),HX_HCSTRING("nominalBitRate","\x91","\xa2","\x66","\x22")},
	{hx::fsInt,(int)offsetof(Header_obj,minimumBitRate),HX_HCSTRING("minimumBitRate","\x1f","\xfa","\xb9","\xf2")},
	{hx::fsInt,(int)offsetof(Header_obj,sampleRate),HX_HCSTRING("sampleRate","\x2a","\x3c","\x4c","\x67")},
	{hx::fsInt,(int)offsetof(Header_obj,channel),HX_HCSTRING("channel","\xc3","\x00","\xd2","\xcc")},
	{hx::fsInt,(int)offsetof(Header_obj,blocksize0),HX_HCSTRING("blocksize0","\xe2","\x3b","\x0f","\xc1")},
	{hx::fsInt,(int)offsetof(Header_obj,blocksize1),HX_HCSTRING("blocksize1","\xe3","\x3b","\x0f","\xc1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Header_obj,codebooks),HX_HCSTRING("codebooks","\xdd","\x0b","\xa1","\xb7")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Header_obj,floorConfig),HX_HCSTRING("floorConfig","\xae","\xfd","\x8a","\x3c")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Header_obj,residueConfig),HX_HCSTRING("residueConfig","\x6d","\x4d","\x6d","\xb1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Header_obj,mapping),HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Header_obj,modes),HX_HCSTRING("modes","\xb0","\x23","\x58","\x0c")},
	{hx::fsObject /*::stb::format::vorbis::data::Comment*/ ,(int)offsetof(Header_obj,comment),HX_HCSTRING("comment","\x5f","\x7a","\x70","\x81")},
	{hx::fsString,(int)offsetof(Header_obj,vendor),HX_HCSTRING("vendor","\x88","\xe5","\x96","\x9e")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Header_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Header_obj::PACKET_ID,HX_HCSTRING("PACKET_ID","\x72","\x37","\x96","\x42")},
	{hx::fsInt,(void *) &Header_obj::PACKET_COMMENT,HX_HCSTRING("PACKET_COMMENT","\x48","\x73","\x92","\xc8")},
	{hx::fsInt,(void *) &Header_obj::PACKET_SETUP,HX_HCSTRING("PACKET_SETUP","\x26","\x87","\x2b","\x68")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Header_obj_sMemberFields[] = {
	HX_HCSTRING("maximumBitRate","\x4d","\x56","\x30","\x56"),
	HX_HCSTRING("nominalBitRate","\x91","\xa2","\x66","\x22"),
	HX_HCSTRING("minimumBitRate","\x1f","\xfa","\xb9","\xf2"),
	HX_HCSTRING("sampleRate","\x2a","\x3c","\x4c","\x67"),
	HX_HCSTRING("channel","\xc3","\x00","\xd2","\xcc"),
	HX_HCSTRING("blocksize0","\xe2","\x3b","\x0f","\xc1"),
	HX_HCSTRING("blocksize1","\xe3","\x3b","\x0f","\xc1"),
	HX_HCSTRING("codebooks","\xdd","\x0b","\xa1","\xb7"),
	HX_HCSTRING("floorConfig","\xae","\xfd","\x8a","\x3c"),
	HX_HCSTRING("residueConfig","\x6d","\x4d","\x6d","\xb1"),
	HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"),
	HX_HCSTRING("modes","\xb0","\x23","\x58","\x0c"),
	HX_HCSTRING("comment","\x5f","\x7a","\x70","\x81"),
	HX_HCSTRING("vendor","\x88","\xe5","\x96","\x9e"),
	::String(null()) };

static void Header_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Header_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_ID,"PACKET_ID");
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_COMMENT,"PACKET_COMMENT");
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_SETUP,"PACKET_SETUP");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Header_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Header_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_ID,"PACKET_ID");
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_COMMENT,"PACKET_COMMENT");
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_SETUP,"PACKET_SETUP");
};

#endif

hx::Class Header_obj::__mClass;

static ::String Header_obj_sStaticFields[] = {
	HX_HCSTRING("PACKET_ID","\x72","\x37","\x96","\x42"),
	HX_HCSTRING("PACKET_COMMENT","\x48","\x73","\x92","\xc8"),
	HX_HCSTRING("PACKET_SETUP","\x26","\x87","\x2b","\x68"),
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null())
};

void Header_obj::__register()
{
	hx::Object *dummy = new Header_obj;
	Header_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("stb.format.vorbis.data.Header","\xa0","\xac","\x33","\x5d");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Header_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Header_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Header_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Header_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Header_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Header_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Header_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Header_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Header_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_d4550658b1516b0f_18_boot)
HXLINE(  18)		PACKET_ID = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_d4550658b1516b0f_19_boot)
HXLINE(  19)		PACKET_COMMENT = (int)3;
            	}
{
            	HX_STACKFRAME(&_hx_pos_d4550658b1516b0f_20_boot)
HXLINE(  20)		PACKET_SETUP = (int)5;
            	}
}

} // end namespace stb
} // end namespace format
} // end namespace vorbis
} // end namespace data
